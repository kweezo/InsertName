Thread 0, Frame 0:
vkCreateInstance(pCreateInfo, pAllocator, pInstance) returns VkResult VK_SUCCESS (0):
    pCreateInfo:                    const VkInstanceCreateInfo* = 0x7fff3fe835b0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO (1)
        pNext:                          const void* = NULL
        flags:                          VkInstanceCreateFlags = 0
        pApplicationInfo:               const VkApplicationInfo* = 0x7fff3fe86ac0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_APPLICATION_INFO (0)
            pNext:                          const void* = NULL
            pApplicationName:               const char* = "Client"
            applicationVersion:             uint32_t = 4194304
            pEngineName:                    const char* = "Niko je weeb"
            engineVersion:                  uint32_t = 4194304
            apiVersion:                     uint32_t = 4206592
        enabledLayerCount:              uint32_t = 2
        ppEnabledLayerNames:            const char* const* = 0x59d134af7ed0
            ppEnabledLayerNames[0]:         const char* const = "VK_LAYER_KHRONOS_validation"
            ppEnabledLayerNames[1]:         const char* const = "VK_LAYER_LUNARG_api_dump"
        enabledExtensionCount:          uint32_t = 3
        ppEnabledExtensionNames:        const char* const* = 0x59d134bab1f0
            ppEnabledExtensionNames[0]:     const char* const = "VK_EXT_debug_utils"
            ppEnabledExtensionNames[1]:     const char* const = "VK_KHR_surface"
            ppEnabledExtensionNames[2]:     const char* const = "VK_KHR_xcb_surface"
        pNext:                          const void* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pInstance:                      VkInstance* = 0x59d134ba5770

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = NULL

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = 0x59d134c7b820
        pPhysicalDevices[0]:            VkPhysicalDevice = 0x59d134c70e80
        pPhysicalDevices[1]:            VkPhysicalDevice = 0x59d134c70eb0

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = 0x59d134c7bbd0
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties = 0x59d134c7bbd0:
            queueFlags:                     VkQueueFlags = 31 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT | VK_QUEUE_PROTECTED_BIT)
            queueCount:                     uint32_t = 1
            timestampValidBits:             uint32_t = 36
            minImageTransferGranularity:    VkExtent3D = 0x59d134c7bbdc:
                width:                          uint32_t = 1
                height:                         uint32_t = 1
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = 0x59d134c7bbf0
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties = 0x59d134c7bbf0:
            queueFlags:                     VkQueueFlags = 7 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT)
            queueCount:                     uint32_t = 1
            timestampValidBits:             uint32_t = 64
            minImageTransferGranularity:    VkExtent3D = 0x59d134c7bbfc:
                width:                          uint32_t = 1
                height:                         uint32_t = 1
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pCreateInfo:                    const VkDebugUtilsMessengerCreateInfoEXT* = 0x7fff3fe86a50:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT (1000128004)
        pNext:                          const void* = NULL
        flags:                          VkDebugUtilsMessengerCreateFlagsEXT = 0
        messageSeverity:                VkDebugUtilsMessageSeverityFlagsEXT = 4368 (VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT)
        messageType:                    VkDebugUtilsMessageTypeFlagsEXT = 7 (VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT)
        pfnUserCallback:                PFN_vkDebugUtilsMessengerCallbackEXT = 1
        pUserData:                      void* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMessenger:                     VkDebugUtilsMessengerEXT* = 0x59d134c68b10

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = NULL

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = 0x59d134c85120
        pPhysicalDevices[0]:            VkPhysicalDevice = 0x59d134c70e80
        pPhysicalDevices[1]:            VkPhysicalDevice = 0x59d134c70eb0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x59d134c85400:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x59d134c85514
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x59d134c85528:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x59d134c85604
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x59d134c85614
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x59d134c85640
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x59d134c85648
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x59d134c856e4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x59d134c856ec
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x59d134c85720:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties* = 0x59d134c858d0:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 1
        vendorID:                       uint32_t = 65541
        deviceID:                       uint32_t = 0
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x59d134c859e4
            pipelineCacheUUID[0]:           uint8_t = 50
            pipelineCacheUUID[1]:           uint8_t = 52
            pipelineCacheUUID[2]:           uint8_t = 46
            pipelineCacheUUID[3]:           uint8_t = 48
            pipelineCacheUUID[4]:           uint8_t = 46
            pipelineCacheUUID[5]:           uint8_t = 48
            pipelineCacheUUID[6]:           uint8_t = 45
            pipelineCacheUUID[7]:           uint8_t = 49
            pipelineCacheUUID[8]:           uint8_t = 112
            pipelineCacheUUID[9]:           uint8_t = 111
            pipelineCacheUUID[10]:          uint8_t = 112
            pipelineCacheUUID[11]:          uint8_t = 48
            pipelineCacheUUID[12]:          uint8_t = 126
            pipelineCacheUUID[13]:          uint8_t = 49
            pipelineCacheUUID[14]:          uint8_t = 55
            pipelineCacheUUID[15]:          uint8_t = 48
        limits:                         VkPhysicalDeviceLimits = 0x59d134c859f8:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 4096
            maxImageDimensionCube:          uint32_t = 32768
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 65536
            maxStorageBufferRange:          uint32_t = 134217728
            maxPushConstantsSize:           uint32_t = 256
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 32768
            bufferImageGranularity:         VkDeviceSize = 64
            sparseAddressSpaceSize:         VkDeviceSize = 0
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 1000000
            maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
            maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
            maxPerStageDescriptorSampledImages: uint32_t = 1000000
            maxPerStageDescriptorStorageImages: uint32_t = 1000000
            maxPerStageDescriptorInputAttachments: uint32_t = 1000000
            maxPerStageResources:           uint32_t = 1000000
            maxDescriptorSetSamplers:       uint32_t = 1000000
            maxDescriptorSetUniformBuffers: uint32_t = 1000000
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetStorageBuffers: uint32_t = 1000000
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetSampledImages:  uint32_t = 1000000
            maxDescriptorSetStorageImages:  uint32_t = 1000000
            maxDescriptorSetInputAttachments: uint32_t = 1000000
            maxVertexInputAttributes:       uint32_t = 32
            maxVertexInputBindings:         uint32_t = 32
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 2048
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 4096
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 64
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 1024
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 128
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 2
            maxFragmentCombinedOutputResources: uint32_t = 104
            maxComputeSharedMemorySize:     uint32_t = 32768
            maxComputeWorkGroupCount:       uint32_t[3] = 0x59d134c85ad4
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x59d134c85ae4
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 4
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x59d134c85b10
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x59d134c85b18
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32768
            viewportSubPixelBits:           uint32_t = 0
            minMemoryMapAlignment:          size_t = 64
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 16
            minStorageBufferOffsetAlignment: VkDeviceSize = 16
            minTexelOffset:                 int32_t = -32
            maxTexelOffset:                 uint32_t = 31
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -2
            maxInterpolationOffset:         float = 2
            subPixelInterpolationOffsetBits: uint32_t = 8
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 1
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x59d134c85bb4
                pointSizeRange[0]:              float = 0
                pointSizeRange[1]:              float = 255
            lineWidthRange:                 float[2] = 0x59d134c85bbc
                lineWidthRange[0]:              float = 1
                lineWidthRange[1]:              float = 255
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 1
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x59d134c85bf0:
            residencyStandard2DBlockShape:  VkBool32 = 0
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 0
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe86310:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86558
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe865f4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe865fc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe86300:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDevicePCIBusInfoPropertiesEXT
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe86310:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe86558
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe865f4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe865fc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDevicePCIBusInfoPropertiesEXT = 0x7fff3fe862e0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (1000212000)
            pNext:                          void* = NULL
            pciDomain:                      uint32_t = 0
            pciBus:                         uint32_t = 0
            pciDevice:                      uint32_t = 2
            pciFunction:                    uint32_t = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe86310:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 1
        vendorID:                       uint32_t = 65541
        deviceID:                       uint32_t = 0
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
            pipelineCacheUUID[0]:           uint8_t = 50
            pipelineCacheUUID[1]:           uint8_t = 52
            pipelineCacheUUID[2]:           uint8_t = 46
            pipelineCacheUUID[3]:           uint8_t = 48
            pipelineCacheUUID[4]:           uint8_t = 46
            pipelineCacheUUID[5]:           uint8_t = 48
            pipelineCacheUUID[6]:           uint8_t = 45
            pipelineCacheUUID[7]:           uint8_t = 49
            pipelineCacheUUID[8]:           uint8_t = 112
            pipelineCacheUUID[9]:           uint8_t = 111
            pipelineCacheUUID[10]:          uint8_t = 112
            pipelineCacheUUID[11]:          uint8_t = 48
            pipelineCacheUUID[12]:          uint8_t = 126
            pipelineCacheUUID[13]:          uint8_t = 49
            pipelineCacheUUID[14]:          uint8_t = 55
            pipelineCacheUUID[15]:          uint8_t = 48
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 4096
            maxImageDimensionCube:          uint32_t = 32768
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 65536
            maxStorageBufferRange:          uint32_t = 134217728
            maxPushConstantsSize:           uint32_t = 256
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 32768
            bufferImageGranularity:         VkDeviceSize = 64
            sparseAddressSpaceSize:         VkDeviceSize = 0
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 1000000
            maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
            maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
            maxPerStageDescriptorSampledImages: uint32_t = 1000000
            maxPerStageDescriptorStorageImages: uint32_t = 1000000
            maxPerStageDescriptorInputAttachments: uint32_t = 1000000
            maxPerStageResources:           uint32_t = 1000000
            maxDescriptorSetSamplers:       uint32_t = 1000000
            maxDescriptorSetUniformBuffers: uint32_t = 1000000
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetStorageBuffers: uint32_t = 1000000
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetSampledImages:  uint32_t = 1000000
            maxDescriptorSetStorageImages:  uint32_t = 1000000
            maxDescriptorSetInputAttachments: uint32_t = 1000000
            maxVertexInputAttributes:       uint32_t = 32
            maxVertexInputBindings:         uint32_t = 32
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 2048
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 4096
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 64
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 1024
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 128
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 2
            maxFragmentCombinedOutputResources: uint32_t = 104
            maxComputeSharedMemorySize:     uint32_t = 32768
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 4
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86558
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32768
            viewportSubPixelBits:           uint32_t = 0
            minMemoryMapAlignment:          size_t = 64
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 16
            minStorageBufferOffsetAlignment: VkDeviceSize = 16
            minTexelOffset:                 int32_t = -32
            maxTexelOffset:                 uint32_t = 31
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -2
            maxInterpolationOffset:         float = 2
            subPixelInterpolationOffsetBits: uint32_t = 8
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 1
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe865f4
                pointSizeRange[0]:              float = 0
                pointSizeRange[1]:              float = 255
            lineWidthRange:                 float[2] = 0x7fff3fe865fc
                lineWidthRange[0]:              float = 1
                lineWidthRange[1]:              float = 255
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 1
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
            residencyStandard2DBlockShape:  VkBool32 = 0
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 0
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe86300:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDevicePCIBusInfoPropertiesEXT
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe86310:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 1
            vendorID:                       uint32_t = 65541
            deviceID:                       uint32_t = 0
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
                pipelineCacheUUID[0]:           uint8_t = 50
                pipelineCacheUUID[1]:           uint8_t = 52
                pipelineCacheUUID[2]:           uint8_t = 46
                pipelineCacheUUID[3]:           uint8_t = 48
                pipelineCacheUUID[4]:           uint8_t = 46
                pipelineCacheUUID[5]:           uint8_t = 48
                pipelineCacheUUID[6]:           uint8_t = 45
                pipelineCacheUUID[7]:           uint8_t = 49
                pipelineCacheUUID[8]:           uint8_t = 112
                pipelineCacheUUID[9]:           uint8_t = 111
                pipelineCacheUUID[10]:          uint8_t = 112
                pipelineCacheUUID[11]:          uint8_t = 48
                pipelineCacheUUID[12]:          uint8_t = 126
                pipelineCacheUUID[13]:          uint8_t = 49
                pipelineCacheUUID[14]:          uint8_t = 55
                pipelineCacheUUID[15]:          uint8_t = 48
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 4096
                maxImageDimensionCube:          uint32_t = 32768
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 65536
                maxStorageBufferRange:          uint32_t = 134217728
                maxPushConstantsSize:           uint32_t = 256
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 32768
                bufferImageGranularity:         VkDeviceSize = 64
                sparseAddressSpaceSize:         VkDeviceSize = 0
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 1000000
                maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
                maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
                maxPerStageDescriptorSampledImages: uint32_t = 1000000
                maxPerStageDescriptorStorageImages: uint32_t = 1000000
                maxPerStageDescriptorInputAttachments: uint32_t = 1000000
                maxPerStageResources:           uint32_t = 1000000
                maxDescriptorSetSamplers:       uint32_t = 1000000
                maxDescriptorSetUniformBuffers: uint32_t = 1000000
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
                maxDescriptorSetStorageBuffers: uint32_t = 1000000
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
                maxDescriptorSetSampledImages:  uint32_t = 1000000
                maxDescriptorSetStorageImages:  uint32_t = 1000000
                maxDescriptorSetInputAttachments: uint32_t = 1000000
                maxVertexInputAttributes:       uint32_t = 32
                maxVertexInputBindings:         uint32_t = 32
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 2048
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 4096
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 64
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 1024
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 128
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 2
                maxFragmentCombinedOutputResources: uint32_t = 104
                maxComputeSharedMemorySize:     uint32_t = 32768
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 4
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe86558
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32768
                viewportSubPixelBits:           uint32_t = 0
                minMemoryMapAlignment:          size_t = 64
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 16
                minStorageBufferOffsetAlignment: VkDeviceSize = 16
                minTexelOffset:                 int32_t = -32
                maxTexelOffset:                 uint32_t = 31
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -2
                maxInterpolationOffset:         float = 2
                subPixelInterpolationOffsetBits: uint32_t = 8
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 1
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe865f4
                    pointSizeRange[0]:              float = 0
                    pointSizeRange[1]:              float = 255
                lineWidthRange:                 float[2] = 0x7fff3fe865fc
                    lineWidthRange[0]:              float = 1
                    lineWidthRange[1]:              float = 255
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 1
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
                residencyStandard2DBlockShape:  VkBool32 = 0
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 0
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 0
        pNext:                          VkPhysicalDevicePCIBusInfoPropertiesEXT = 0x7fff3fe862e0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (1000212000)
            pNext:                          void* = NULL
            pciDomain:                      uint32_t = 0
            pciBus:                         uint32_t = 0
            pciDevice:                      uint32_t = 0
            pciFunction:                    uint32_t = 0

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = NULL

Thread 0, Frame 0:
vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pPhysicalDeviceCount:           uint32_t* = 2
    pPhysicalDevices:               VkPhysicalDevice* = 0x59d134c85160
        pPhysicalDevices[0]:            VkPhysicalDevice = 0x59d134c70e80
        pPhysicalDevices[1]:            VkPhysicalDevice = 0x59d134c70eb0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe86310:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86558
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe865f4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe865fc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe86300:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDevicePCIBusInfoPropertiesEXT
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe86310:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe86558
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe865f4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe865fc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDevicePCIBusInfoPropertiesEXT = 0x7fff3fe862e0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (1000212000)
            pNext:                          void* = NULL
            pciDomain:                      uint32_t = 0
            pciBus:                         uint32_t = 0
            pciDevice:                      uint32_t = 2
            pciFunction:                    uint32_t = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe86310:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 1
        vendorID:                       uint32_t = 65541
        deviceID:                       uint32_t = 0
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
            pipelineCacheUUID[0]:           uint8_t = 50
            pipelineCacheUUID[1]:           uint8_t = 52
            pipelineCacheUUID[2]:           uint8_t = 46
            pipelineCacheUUID[3]:           uint8_t = 48
            pipelineCacheUUID[4]:           uint8_t = 46
            pipelineCacheUUID[5]:           uint8_t = 48
            pipelineCacheUUID[6]:           uint8_t = 45
            pipelineCacheUUID[7]:           uint8_t = 49
            pipelineCacheUUID[8]:           uint8_t = 112
            pipelineCacheUUID[9]:           uint8_t = 111
            pipelineCacheUUID[10]:          uint8_t = 112
            pipelineCacheUUID[11]:          uint8_t = 48
            pipelineCacheUUID[12]:          uint8_t = 126
            pipelineCacheUUID[13]:          uint8_t = 49
            pipelineCacheUUID[14]:          uint8_t = 55
            pipelineCacheUUID[15]:          uint8_t = 48
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 4096
            maxImageDimensionCube:          uint32_t = 32768
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 65536
            maxStorageBufferRange:          uint32_t = 134217728
            maxPushConstantsSize:           uint32_t = 256
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 32768
            bufferImageGranularity:         VkDeviceSize = 64
            sparseAddressSpaceSize:         VkDeviceSize = 0
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 1000000
            maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
            maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
            maxPerStageDescriptorSampledImages: uint32_t = 1000000
            maxPerStageDescriptorStorageImages: uint32_t = 1000000
            maxPerStageDescriptorInputAttachments: uint32_t = 1000000
            maxPerStageResources:           uint32_t = 1000000
            maxDescriptorSetSamplers:       uint32_t = 1000000
            maxDescriptorSetUniformBuffers: uint32_t = 1000000
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetStorageBuffers: uint32_t = 1000000
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetSampledImages:  uint32_t = 1000000
            maxDescriptorSetStorageImages:  uint32_t = 1000000
            maxDescriptorSetInputAttachments: uint32_t = 1000000
            maxVertexInputAttributes:       uint32_t = 32
            maxVertexInputBindings:         uint32_t = 32
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 2048
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 4096
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 64
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 1024
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 128
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 2
            maxFragmentCombinedOutputResources: uint32_t = 104
            maxComputeSharedMemorySize:     uint32_t = 32768
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 4
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86558
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32768
            viewportSubPixelBits:           uint32_t = 0
            minMemoryMapAlignment:          size_t = 64
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 16
            minStorageBufferOffsetAlignment: VkDeviceSize = 16
            minTexelOffset:                 int32_t = -32
            maxTexelOffset:                 uint32_t = 31
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -2
            maxInterpolationOffset:         float = 2
            subPixelInterpolationOffsetBits: uint32_t = 8
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 1
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe865f4
                pointSizeRange[0]:              float = 0
                pointSizeRange[1]:              float = 255
            lineWidthRange:                 float[2] = 0x7fff3fe865fc
                lineWidthRange[0]:              float = 1
                lineWidthRange[1]:              float = 255
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 1
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
            residencyStandard2DBlockShape:  VkBool32 = 0
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 0
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe86300:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDevicePCIBusInfoPropertiesEXT
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe86310:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 1
            vendorID:                       uint32_t = 65541
            deviceID:                       uint32_t = 0
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86424
                pipelineCacheUUID[0]:           uint8_t = 50
                pipelineCacheUUID[1]:           uint8_t = 52
                pipelineCacheUUID[2]:           uint8_t = 46
                pipelineCacheUUID[3]:           uint8_t = 48
                pipelineCacheUUID[4]:           uint8_t = 46
                pipelineCacheUUID[5]:           uint8_t = 48
                pipelineCacheUUID[6]:           uint8_t = 45
                pipelineCacheUUID[7]:           uint8_t = 49
                pipelineCacheUUID[8]:           uint8_t = 112
                pipelineCacheUUID[9]:           uint8_t = 111
                pipelineCacheUUID[10]:          uint8_t = 112
                pipelineCacheUUID[11]:          uint8_t = 48
                pipelineCacheUUID[12]:          uint8_t = 126
                pipelineCacheUUID[13]:          uint8_t = 49
                pipelineCacheUUID[14]:          uint8_t = 55
                pipelineCacheUUID[15]:          uint8_t = 48
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86438:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 4096
                maxImageDimensionCube:          uint32_t = 32768
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 65536
                maxStorageBufferRange:          uint32_t = 134217728
                maxPushConstantsSize:           uint32_t = 256
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 32768
                bufferImageGranularity:         VkDeviceSize = 64
                sparseAddressSpaceSize:         VkDeviceSize = 0
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 1000000
                maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
                maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
                maxPerStageDescriptorSampledImages: uint32_t = 1000000
                maxPerStageDescriptorStorageImages: uint32_t = 1000000
                maxPerStageDescriptorInputAttachments: uint32_t = 1000000
                maxPerStageResources:           uint32_t = 1000000
                maxDescriptorSetSamplers:       uint32_t = 1000000
                maxDescriptorSetUniformBuffers: uint32_t = 1000000
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
                maxDescriptorSetStorageBuffers: uint32_t = 1000000
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
                maxDescriptorSetSampledImages:  uint32_t = 1000000
                maxDescriptorSetStorageImages:  uint32_t = 1000000
                maxDescriptorSetInputAttachments: uint32_t = 1000000
                maxVertexInputAttributes:       uint32_t = 32
                maxVertexInputBindings:         uint32_t = 32
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 2048
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 4096
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 64
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 1024
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 128
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 2
                maxFragmentCombinedOutputResources: uint32_t = 104
                maxComputeSharedMemorySize:     uint32_t = 32768
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe86514
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86524
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 4
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86550
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe86558
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32768
                viewportSubPixelBits:           uint32_t = 0
                minMemoryMapAlignment:          size_t = 64
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 16
                minStorageBufferOffsetAlignment: VkDeviceSize = 16
                minTexelOffset:                 int32_t = -32
                maxTexelOffset:                 uint32_t = 31
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -2
                maxInterpolationOffset:         float = 2
                subPixelInterpolationOffsetBits: uint32_t = 8
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 1
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe865f4
                    pointSizeRange[0]:              float = 0
                    pointSizeRange[1]:              float = 255
                lineWidthRange:                 float[2] = 0x7fff3fe865fc
                    lineWidthRange[0]:              float = 1
                    lineWidthRange[1]:              float = 255
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 1
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86630:
                residencyStandard2DBlockShape:  VkBool32 = 0
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 0
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 0
        pNext:                          VkPhysicalDevicePCIBusInfoPropertiesEXT = 0x7fff3fe862e0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (1000212000)
            pNext:                          void* = NULL
            pciDomain:                      uint32_t = 0
            pciBus:                         uint32_t = 0
            pciDevice:                      uint32_t = 0
            pciFunction:                    uint32_t = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe867f0:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86904
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86918:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe869f4
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86a04
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86a30
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86a38
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe86ad4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe86adc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86b10:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70eb0
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe867f0:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 1
        vendorID:                       uint32_t = 65541
        deviceID:                       uint32_t = 0
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_CPU (4)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "llvmpipe (LLVM 15.0.7, 256 bits)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86904
            pipelineCacheUUID[0]:           uint8_t = 50
            pipelineCacheUUID[1]:           uint8_t = 52
            pipelineCacheUUID[2]:           uint8_t = 46
            pipelineCacheUUID[3]:           uint8_t = 48
            pipelineCacheUUID[4]:           uint8_t = 46
            pipelineCacheUUID[5]:           uint8_t = 48
            pipelineCacheUUID[6]:           uint8_t = 45
            pipelineCacheUUID[7]:           uint8_t = 49
            pipelineCacheUUID[8]:           uint8_t = 112
            pipelineCacheUUID[9]:           uint8_t = 111
            pipelineCacheUUID[10]:          uint8_t = 112
            pipelineCacheUUID[11]:          uint8_t = 48
            pipelineCacheUUID[12]:          uint8_t = 126
            pipelineCacheUUID[13]:          uint8_t = 49
            pipelineCacheUUID[14]:          uint8_t = 55
            pipelineCacheUUID[15]:          uint8_t = 48
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86918:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 4096
            maxImageDimensionCube:          uint32_t = 32768
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 65536
            maxStorageBufferRange:          uint32_t = 134217728
            maxPushConstantsSize:           uint32_t = 256
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 32768
            bufferImageGranularity:         VkDeviceSize = 64
            sparseAddressSpaceSize:         VkDeviceSize = 0
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 1000000
            maxPerStageDescriptorUniformBuffers: uint32_t = 1000000
            maxPerStageDescriptorStorageBuffers: uint32_t = 1000000
            maxPerStageDescriptorSampledImages: uint32_t = 1000000
            maxPerStageDescriptorStorageImages: uint32_t = 1000000
            maxPerStageDescriptorInputAttachments: uint32_t = 1000000
            maxPerStageResources:           uint32_t = 1000000
            maxDescriptorSetSamplers:       uint32_t = 1000000
            maxDescriptorSetUniformBuffers: uint32_t = 1000000
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetStorageBuffers: uint32_t = 1000000
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 1000000
            maxDescriptorSetSampledImages:  uint32_t = 1000000
            maxDescriptorSetStorageImages:  uint32_t = 1000000
            maxDescriptorSetInputAttachments: uint32_t = 1000000
            maxVertexInputAttributes:       uint32_t = 32
            maxVertexInputBindings:         uint32_t = 32
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 2048
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 4096
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 64
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 1024
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 128
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 2
            maxFragmentCombinedOutputResources: uint32_t = 104
            maxComputeSharedMemorySize:     uint32_t = 32768
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe869f4
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86a04
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 4
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86a30
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86a38
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32768
            viewportSubPixelBits:           uint32_t = 0
            minMemoryMapAlignment:          size_t = 64
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 16
            minStorageBufferOffsetAlignment: VkDeviceSize = 16
            minTexelOffset:                 int32_t = -32
            maxTexelOffset:                 uint32_t = 31
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -2
            maxInterpolationOffset:         float = 2
            subPixelInterpolationOffsetBits: uint32_t = 8
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 5 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_4_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 1
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe86ad4
                pointSizeRange[0]:              float = 0
                pointSizeRange[1]:              float = 255
            lineWidthRange:                 float[2] = 0x7fff3fe86adc
                lineWidthRange[0]:              float = 1
                lineWidthRange[1]:              float = 255
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 1
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86b10:
            residencyStandard2DBlockShape:  VkBool32 = 0
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 0
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 0

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe867f0:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe86904
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86918:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe869f4
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe86a04
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86a30
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86a38
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe86ad4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe86adc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86b10:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Using device: Intel(R) Graphics (RPL-P)
Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = 0x59d134c38bf0
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties = 0x59d134c38bf0:
            queueFlags:                     VkQueueFlags = 31 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT | VK_QUEUE_PROTECTED_BIT)
            queueCount:                     uint32_t = 1
            timestampValidBits:             uint32_t = 36
            minImageTransferGranularity:    VkExtent3D = 0x59d134c38bfc:
                width:                          uint32_t = 1
                height:                         uint32_t = 1
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe863e0:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe864f4
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe86508:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe865e4
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe865f4
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe86620
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe86628
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe866c4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe866cc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe86700:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pCreateInfo:                    const VkDeviceCreateInfo* = 0x7fff3fe86120:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO (3)
        pNext:                          const void* = NULL
        flags:                          VkDeviceCreateFlags = 0
        queueCreateInfoCount:           uint32_t = 1
        pQueueCreateInfos:              const VkDeviceQueueCreateInfo* = 0x59d134c728e8
            pQueueCreateInfos[0]:           const VkDeviceQueueCreateInfo = 0x59d134c728e8:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO (2)
                pNext:                          const void* = NULL
                flags:                          VkDeviceQueueCreateFlags = 0
                queueFamilyIndex:               uint32_t = 0
                queueCount:                     uint32_t = 1
                pQueuePriorities:               const float* = 0x59d134c657c0
                    pQueuePriorities[0]:            const float = 1
        enabledLayerCount:              uint32_t = 0
        ppEnabledLayerNames:            const char* const* = 0x59d134c7b840
        enabledExtensionCount:          uint32_t = 1
        ppEnabledExtensionNames:        const char* const* = 0x59d134c38bb0
            ppEnabledExtensionNames[0]:     const char* const = "VK_KHR_swapchain"
        pEnabledFeatures:               const VkPhysicalDeviceFeatures* = NULL
        pNext:                          const void* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pDevice:                        VkDevice* = 0x59d134c89710

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x7fff3fe85910:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85c50:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceMaintenance4Properties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85c60:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85d74
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85d88:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85e64
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85e74
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85ea0
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85ea8
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85f44
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85f4c
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85f80:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceMaintenance4Properties = 0x7fff3fe85780:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES (1000413001)
            pNext:                          void* = NULL
            maxBufferSize:                  VkDeviceSize = 4294967296

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85c50:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceDepthStencilResolveProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85c60:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85d74
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85d88:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85e64
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85e74
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85ea0
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85ea8
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85f44
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85f4c
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85f80:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceDepthStencilResolveProperties = 0x7fff3fe85780:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES (1000199000)
            pNext:                          void* = NULL
            supportedDepthResolveModes:     VkResolveModeFlags = 15 (VK_RESOLVE_MODE_SAMPLE_ZERO_BIT | VK_RESOLVE_MODE_AVERAGE_BIT | VK_RESOLVE_MODE_MIN_BIT | VK_RESOLVE_MODE_MAX_BIT)
            supportedStencilResolveModes:   VkResolveModeFlags = 13 (VK_RESOLVE_MODE_SAMPLE_ZERO_BIT | VK_RESOLVE_MODE_MIN_BIT | VK_RESOLVE_MODE_MAX_BIT)
            independentResolveNone:         VkBool32 = 1
            independentResolve:             VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pMemoryProperties:              VkPhysicalDeviceMemoryProperties* = 0x59d134ca7b40:
        memoryTypeCount:                uint32_t = 4
        memoryTypes:                    VkMemoryType[VK_MAX_MEMORY_TYPES] = 0x59d134ca7b44
            memoryTypes[0]:                 VkMemoryType = 0x59d134ca7b44:
                propertyFlags:                  VkMemoryPropertyFlags = 1 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[1]:                 VkMemoryType = 0x59d134ca7b4c:
                propertyFlags:                  VkMemoryPropertyFlags = 7 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[2]:                 VkMemoryType = 0x59d134ca7b54:
                propertyFlags:                  VkMemoryPropertyFlags = 15 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[3]:                 VkMemoryType = 0x59d134ca7b5c:
                propertyFlags:                  VkMemoryPropertyFlags = 33 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_PROTECTED_BIT)
                heapIndex:                      uint32_t = 0
        memoryHeapCount:                uint32_t = 1
        memoryHeaps:                    VkMemoryHeap[VK_MAX_MEMORY_HEAPS] = 0x59d134ca7c48
            memoryHeaps[0]:                 VkMemoryHeap = 0x59d134ca7c48:
                size:                           VkDeviceSize = 12348856320
                flags:                          VkMemoryHeapFlags = 1 (VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties* = 0x59d134ca7d48:
        apiVersion:                     uint32_t = 4206866
        driverVersion:                  uint32_t = 100663296
        vendorID:                       uint32_t = 32902
        deviceID:                       uint32_t = 42912
        deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
        deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
        pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x59d134ca7e5c
            pipelineCacheUUID[0]:           uint8_t = 5
            pipelineCacheUUID[1]:           uint8_t = 224
            pipelineCacheUUID[2]:           uint8_t = 208
            pipelineCacheUUID[3]:           uint8_t = 207
            pipelineCacheUUID[4]:           uint8_t = 45
            pipelineCacheUUID[5]:           uint8_t = 20
            pipelineCacheUUID[6]:           uint8_t = 165
            pipelineCacheUUID[7]:           uint8_t = 192
            pipelineCacheUUID[8]:           uint8_t = 189
            pipelineCacheUUID[9]:           uint8_t = 96
            pipelineCacheUUID[10]:          uint8_t = 69
            pipelineCacheUUID[11]:          uint8_t = 192
            pipelineCacheUUID[12]:          uint8_t = 238
            pipelineCacheUUID[13]:          uint8_t = 171
            pipelineCacheUUID[14]:          uint8_t = 79
            pipelineCacheUUID[15]:          uint8_t = 66
        limits:                         VkPhysicalDeviceLimits = 0x59d134ca7e70:
            maxImageDimension1D:            uint32_t = 16384
            maxImageDimension2D:            uint32_t = 16384
            maxImageDimension3D:            uint32_t = 2048
            maxImageDimensionCube:          uint32_t = 16384
            maxImageArrayLayers:            uint32_t = 2048
            maxTexelBufferElements:         uint32_t = 134217728
            maxUniformBufferRange:          uint32_t = 1073741824
            maxStorageBufferRange:          uint32_t = 4294967295
            maxPushConstantsSize:           uint32_t = 128
            maxMemoryAllocationCount:       uint32_t = 4294967295
            maxSamplerAllocationCount:      uint32_t = 65536
            bufferImageGranularity:         VkDeviceSize = 1
            sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
            maxBoundDescriptorSets:         uint32_t = 8
            maxPerStageDescriptorSamplers:  uint32_t = 65535
            maxPerStageDescriptorUniformBuffers: uint32_t = 64
            maxPerStageDescriptorStorageBuffers: uint32_t = 65535
            maxPerStageDescriptorSampledImages: uint32_t = 65535
            maxPerStageDescriptorStorageImages: uint32_t = 65535
            maxPerStageDescriptorInputAttachments: uint32_t = 64
            maxPerStageResources:           uint32_t = 4294967295
            maxDescriptorSetSamplers:       uint32_t = 393210
            maxDescriptorSetUniformBuffers: uint32_t = 384
            maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetStorageBuffers: uint32_t = 393210
            maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetSampledImages:  uint32_t = 393210
            maxDescriptorSetStorageImages:  uint32_t = 393210
            maxDescriptorSetInputAttachments: uint32_t = 256
            maxVertexInputAttributes:       uint32_t = 29
            maxVertexInputBindings:         uint32_t = 31
            maxVertexInputAttributeOffset:  uint32_t = 2047
            maxVertexInputBindingStride:    uint32_t = 4095
            maxVertexOutputComponents:      uint32_t = 128
            maxTessellationGenerationLevel: uint32_t = 64
            maxTessellationPatchSize:       uint32_t = 32
            maxTessellationControlPerVertexInputComponents: uint32_t = 128
            maxTessellationControlPerVertexOutputComponents: uint32_t = 128
            maxTessellationControlPerPatchOutputComponents: uint32_t = 128
            maxTessellationControlTotalOutputComponents: uint32_t = 2048
            maxTessellationEvaluationInputComponents: uint32_t = 128
            maxTessellationEvaluationOutputComponents: uint32_t = 128
            maxGeometryShaderInvocations:   uint32_t = 32
            maxGeometryInputComponents:     uint32_t = 128
            maxGeometryOutputComponents:    uint32_t = 128
            maxGeometryOutputVertices:      uint32_t = 256
            maxGeometryTotalOutputComponents: uint32_t = 1024
            maxFragmentInputComponents:     uint32_t = 116
            maxFragmentOutputAttachments:   uint32_t = 8
            maxFragmentDualSrcAttachments:  uint32_t = 1
            maxFragmentCombinedOutputResources: uint32_t = 131078
            maxComputeSharedMemorySize:     uint32_t = 65536
            maxComputeWorkGroupCount:       uint32_t[3] = 0x59d134ca7f4c
                maxComputeWorkGroupCount[0]:    uint32_t = 65535
                maxComputeWorkGroupCount[1]:    uint32_t = 65535
                maxComputeWorkGroupCount[2]:    uint32_t = 65535
            maxComputeWorkGroupInvocations: uint32_t = 1024
            maxComputeWorkGroupSize:        uint32_t[3] = 0x59d134ca7f5c
                maxComputeWorkGroupSize[0]:     uint32_t = 1024
                maxComputeWorkGroupSize[1]:     uint32_t = 1024
                maxComputeWorkGroupSize[2]:     uint32_t = 1024
            subPixelPrecisionBits:          uint32_t = 8
            subTexelPrecisionBits:          uint32_t = 8
            mipmapPrecisionBits:            uint32_t = 8
            maxDrawIndexedIndexValue:       uint32_t = 4294967295
            maxDrawIndirectCount:           uint32_t = 4294967295
            maxSamplerLodBias:              float = 16
            maxSamplerAnisotropy:           float = 16
            maxViewports:                   uint32_t = 16
            maxViewportDimensions:          uint32_t[2] = 0x59d134ca7f88
                maxViewportDimensions[0]:       uint32_t = 16384
                maxViewportDimensions[1]:       uint32_t = 16384
            viewportBoundsRange:            float[2] = 0x59d134ca7f90
                viewportBoundsRange[0]:         float = -32768
                viewportBoundsRange[1]:         float = 32767
            viewportSubPixelBits:           uint32_t = 13
            minMemoryMapAlignment:          size_t = 4096
            minTexelBufferOffsetAlignment:  VkDeviceSize = 16
            minUniformBufferOffsetAlignment: VkDeviceSize = 64
            minStorageBufferOffsetAlignment: VkDeviceSize = 4
            minTexelOffset:                 int32_t = -8
            maxTexelOffset:                 uint32_t = 7
            minTexelGatherOffset:           int32_t = -32
            maxTexelGatherOffset:           uint32_t = 31
            minInterpolationOffset:         float = -0.5
            maxInterpolationOffset:         float = 0.4375
            subPixelInterpolationOffsetBits: uint32_t = 4
            maxFramebufferWidth:            uint32_t = 16384
            maxFramebufferHeight:           uint32_t = 16384
            maxFramebufferLayers:           uint32_t = 2048
            framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            maxColorAttachments:            uint32_t = 8
            sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
            storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
            maxSampleMaskWords:             uint32_t = 1
            timestampComputeAndGraphics:    VkBool32 = 1
            timestampPeriod:                float = 52.0833
            maxClipDistances:               uint32_t = 8
            maxCullDistances:               uint32_t = 8
            maxCombinedClipAndCullDistances: uint32_t = 8
            discreteQueuePriorities:        uint32_t = 2
            pointSizeRange:                 float[2] = 0x59d134ca802c
                pointSizeRange[0]:              float = 0.125
                pointSizeRange[1]:              float = 255.875
            lineWidthRange:                 float[2] = 0x59d134ca8034
                lineWidthRange[0]:              float = 0
                lineWidthRange[1]:              float = 8
            pointSizeGranularity:           float = 0.125
            lineWidthGranularity:           float = 0.0078125
            strictLines:                    VkBool32 = 0
            standardSampleLocations:        VkBool32 = 1
            optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
            optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
            nonCoherentAtomSize:            VkDeviceSize = 64
        sparseProperties:               VkPhysicalDeviceSparseProperties = 0x59d134ca8068:
            residencyStandard2DBlockShape:  VkBool32 = 1
            residencyStandard2DMultisampleBlockShape: VkBool32 = 0
            residencyStandard3DBlockShape:  VkBool32 = 1
            residencyAlignedMipSize:        VkBool32 = 0
            residencyNonResidentStrict:     VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceVulkan11Properties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceVulkan11Properties = 0x59d134ca8080:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES (50)
            pNext:                          void* = NULL
            deviceUUID:                     uint8_t[VK_UUID_SIZE] = 0x59d134ca8090
                deviceUUID[0]:                  uint8_t = 134
                deviceUUID[1]:                  uint8_t = 128
                deviceUUID[2]:                  uint8_t = 160
                deviceUUID[3]:                  uint8_t = 167
                deviceUUID[4]:                  uint8_t = 4
                deviceUUID[5]:                  uint8_t = 0
                deviceUUID[6]:                  uint8_t = 0
                deviceUUID[7]:                  uint8_t = 0
                deviceUUID[8]:                  uint8_t = 0
                deviceUUID[9]:                  uint8_t = 2
                deviceUUID[10]:                 uint8_t = 0
                deviceUUID[11]:                 uint8_t = 0
                deviceUUID[12]:                 uint8_t = 0
                deviceUUID[13]:                 uint8_t = 0
                deviceUUID[14]:                 uint8_t = 0
                deviceUUID[15]:                 uint8_t = 0
            driverUUID:                     uint8_t[VK_UUID_SIZE] = 0x59d134ca80a0
                driverUUID[0]:                  uint8_t = 39
                driverUUID[1]:                  uint8_t = 134
                driverUUID[2]:                  uint8_t = 252
                driverUUID[3]:                  uint8_t = 160
                driverUUID[4]:                  uint8_t = 31
                driverUUID[5]:                  uint8_t = 113
                driverUUID[6]:                  uint8_t = 103
                driverUUID[7]:                  uint8_t = 172
                driverUUID[8]:                  uint8_t = 87
                driverUUID[9]:                  uint8_t = 76
                driverUUID[10]:                 uint8_t = 111
                driverUUID[11]:                 uint8_t = 69
                driverUUID[12]:                 uint8_t = 111
                driverUUID[13]:                 uint8_t = 55
                driverUUID[14]:                 uint8_t = 51
                driverUUID[15]:                 uint8_t = 117
            deviceLUID:                     uint8_t[VK_LUID_SIZE] = 0x59d134ca80b0
                deviceLUID[0]:                  uint8_t = 0
                deviceLUID[1]:                  uint8_t = 0
                deviceLUID[2]:                  uint8_t = 0
                deviceLUID[3]:                  uint8_t = 0
                deviceLUID[4]:                  uint8_t = 0
                deviceLUID[5]:                  uint8_t = 0
                deviceLUID[6]:                  uint8_t = 0
                deviceLUID[7]:                  uint8_t = 0
            deviceNodeMask:                 uint32_t = 0
            deviceLUIDValid:                VkBool32 = 0
            subgroupSize:                   uint32_t = 32
            subgroupSupportedStages:        VkShaderStageFlags = 63 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT | VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_COMPUTE_BIT)
            subgroupSupportedOperations:    VkSubgroupFeatureFlags = 255 (VK_SUBGROUP_FEATURE_BASIC_BIT | VK_SUBGROUP_FEATURE_VOTE_BIT | VK_SUBGROUP_FEATURE_ARITHMETIC_BIT | VK_SUBGROUP_FEATURE_BALLOT_BIT | VK_SUBGROUP_FEATURE_SHUFFLE_BIT | VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT | VK_SUBGROUP_FEATURE_CLUSTERED_BIT | VK_SUBGROUP_FEATURE_QUAD_BIT)
            subgroupQuadOperationsInAllStages: VkBool32 = 1
            pointClippingBehavior:          VkPointClippingBehavior = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY (1)
            maxMultiviewViewCount:          uint32_t = 16
            maxMultiviewInstanceIndex:      uint32_t = 268435455
            protectedNoFault:               VkBool32 = 1
            maxPerSetDescriptors:           uint32_t = 1024
            maxMemoryAllocationSize:        VkDeviceSize = 12348856320

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceVulkan12Properties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceVulkan12Properties = 0x59d134ca80f0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES (52)
            pNext:                          void* = NULL
            driverID:                       VkDriverId = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA (6)
            driverName:                     char[VK_MAX_DRIVER_NAME_SIZE] = "Intel open-source Mesa driver"
            driverInfo:                     char[VK_MAX_DRIVER_INFO_SIZE] = "Mesa 24.0.0-1pop0~1706872735~22.04~0fa430c"
            conformanceVersion:             VkConformanceVersion = 0x59d134ca8304:
                major:                          uint8_t = 1
                minor:                          uint8_t = 3
                subminor:                       uint8_t = 6
                patch:                          uint8_t = 0
            denormBehaviorIndependence:     VkShaderFloatControlsIndependence = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL (1)
            roundingModeIndependence:       VkShaderFloatControlsIndependence = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE (2)
            shaderSignedZeroInfNanPreserveFloat16: VkBool32 = 1
            shaderSignedZeroInfNanPreserveFloat32: VkBool32 = 1
            shaderSignedZeroInfNanPreserveFloat64: VkBool32 = 1
            shaderDenormPreserveFloat16:    VkBool32 = 1
            shaderDenormPreserveFloat32:    VkBool32 = 1
            shaderDenormPreserveFloat64:    VkBool32 = 1
            shaderDenormFlushToZeroFloat16: VkBool32 = 0
            shaderDenormFlushToZeroFloat32: VkBool32 = 1
            shaderDenormFlushToZeroFloat64: VkBool32 = 1
            shaderRoundingModeRTEFloat16:   VkBool32 = 1
            shaderRoundingModeRTEFloat32:   VkBool32 = 1
            shaderRoundingModeRTEFloat64:   VkBool32 = 1
            shaderRoundingModeRTZFloat16:   VkBool32 = 1
            shaderRoundingModeRTZFloat32:   VkBool32 = 1
            shaderRoundingModeRTZFloat64:   VkBool32 = 1
            maxUpdateAfterBindDescriptorsInAllPools: uint32_t = 1048576
            shaderUniformBufferArrayNonUniformIndexingNative: VkBool32 = 0
            shaderSampledImageArrayNonUniformIndexingNative: VkBool32 = 0
            shaderStorageBufferArrayNonUniformIndexingNative: VkBool32 = 1
            shaderStorageImageArrayNonUniformIndexingNative: VkBool32 = 0
            shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32 = 0
            robustBufferAccessUpdateAfterBind: VkBool32 = 1
            quadDivergentImplicitLod:       VkBool32 = 0
            maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t = 1048576
            maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t = 64
            maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t = 4294967295
            maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t = 1048576
            maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t = 1048576
            maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t = 64
            maxPerStageUpdateAfterBindResources: uint32_t = 4294967295
            maxDescriptorSetUpdateAfterBindSamplers: uint32_t = 1048576
            maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t = 384
            maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t = 8
            maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t = 4294967295
            maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t = 8
            maxDescriptorSetUpdateAfterBindSampledImages: uint32_t = 1048576
            maxDescriptorSetUpdateAfterBindStorageImages: uint32_t = 1048576
            maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t = 256
            supportedDepthResolveModes:     VkResolveModeFlags = 15 (VK_RESOLVE_MODE_SAMPLE_ZERO_BIT | VK_RESOLVE_MODE_AVERAGE_BIT | VK_RESOLVE_MODE_MIN_BIT | VK_RESOLVE_MODE_MAX_BIT)
            supportedStencilResolveModes:   VkResolveModeFlags = 13 (VK_RESOLVE_MODE_SAMPLE_ZERO_BIT | VK_RESOLVE_MODE_MIN_BIT | VK_RESOLVE_MODE_MAX_BIT)
            independentResolveNone:         VkBool32 = 1
            independentResolve:             VkBool32 = 1
            filterMinmaxSingleComponentFormats: VkBool32 = 1
            filterMinmaxImageComponentMapping: VkBool32 = 1
            maxTimelineSemaphoreValueDifference: uint64_t = 18446744073709551615
            framebufferIntegerColorSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceVulkan13Properties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceVulkan13Properties = 0x59d134ca83d0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES (54)
            pNext:                          void* = NULL
            minSubgroupSize:                uint32_t = 8
            maxSubgroupSize:                uint32_t = 32
            maxComputeWorkgroupSubgroups:   uint32_t = 64
            requiredSubgroupSizeStages:     VkShaderStageFlags = 224 (VK_SHADER_STAGE_COMPUTE_BIT | VK_SHADER_STAGE_TASK_BIT_EXT | VK_SHADER_STAGE_MESH_BIT_EXT)
            maxInlineUniformBlockSize:      uint32_t = 4096
            maxPerStageDescriptorInlineUniformBlocks: uint32_t = 32
            maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t = 32
            maxDescriptorSetInlineUniformBlocks: uint32_t = 32
            maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t = 32
            maxInlineUniformTotalSize:      uint32_t = 65535
            integerDotProduct8BitUnsignedAccelerated: VkBool32 = 0
            integerDotProduct8BitSignedAccelerated: VkBool32 = 0
            integerDotProduct8BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32 = 1
            integerDotProduct4x8BitPackedSignedAccelerated: VkBool32 = 1
            integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32 = 1
            integerDotProduct16BitUnsignedAccelerated: VkBool32 = 0
            integerDotProduct16BitSignedAccelerated: VkBool32 = 0
            integerDotProduct16BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProduct32BitUnsignedAccelerated: VkBool32 = 0
            integerDotProduct32BitSignedAccelerated: VkBool32 = 0
            integerDotProduct32BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProduct64BitUnsignedAccelerated: VkBool32 = 0
            integerDotProduct64BitSignedAccelerated: VkBool32 = 0
            integerDotProduct64BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32 = 1
            integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32 = 1
            integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32 = 1
            integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32 = 0
            integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32 = 0
            storageTexelBufferOffsetAlignmentBytes: VkDeviceSize = 16
            storageTexelBufferOffsetSingleTexelAlignment: VkBool32 = 1
            uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize = 1
            uniformTexelBufferOffsetSingleTexelAlignment: VkBool32 = 1
            maxBufferSize:                  VkDeviceSize = 4294967296

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceInlineUniformBlockProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceInlineUniformBlockProperties = 0x59d134ca8608:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES (1000138001)
            pNext:                          void* = NULL
            maxInlineUniformBlockSize:      uint32_t = 4096
            maxPerStageDescriptorInlineUniformBlocks: uint32_t = 32
            maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t = 32
            maxDescriptorSetInlineUniformBlocks: uint32_t = 32
            maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t = 32

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceTexelBufferAlignmentProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceTexelBufferAlignmentProperties = 0x59d134ca8768:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES (1000281001)
            pNext:                          void* = NULL
            storageTexelBufferOffsetAlignmentBytes: VkDeviceSize = 16
            storageTexelBufferOffsetSingleTexelAlignment: VkBool32 = 1
            uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize = 1
            uniformTexelBufferOffsetSingleTexelAlignment: VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceMultiviewProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceMultiviewProperties = 0x59d134ca8858:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES (1000053002)
            pNext:                          void* = NULL
            maxMultiviewViewCount:          uint32_t = 16
            maxMultiviewInstanceIndex:      uint32_t = 268435455

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceSubgroupSizeControlProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceSubgroupSizeControlProperties = 0x59d134ca8990:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES (1000225000)
            pNext:                          void* = NULL
            minSubgroupSize:                uint32_t = 8
            maxSubgroupSize:                uint32_t = 32
            maxComputeWorkgroupSubgroups:   uint32_t = 64
            requiredSubgroupSizeStages:     VkShaderStageFlags = 224 (VK_SHADER_STAGE_COMPUTE_BIT | VK_SHADER_STAGE_TASK_BIT_EXT | VK_SHADER_STAGE_MESH_BIT_EXT)

Thread 0, Frame 0:
vkGetPhysicalDeviceProperties2(physicalDevice, pProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pProperties:                    VkPhysicalDeviceProperties2* = 0x7fff3fe85900:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (1000059001)
        pNext:                          void* = VkPhysicalDeviceSubgroupProperties
        properties:                     VkPhysicalDeviceProperties = 0x7fff3fe85910:
            apiVersion:                     uint32_t = 4206866
            driverVersion:                  uint32_t = 100663296
            vendorID:                       uint32_t = 32902
            deviceID:                       uint32_t = 42912
            deviceType:                     VkPhysicalDeviceType = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (1)
            deviceName:                     char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE] = "Intel(R) Graphics (RPL-P)"
            pipelineCacheUUID:              uint8_t[VK_UUID_SIZE] = 0x7fff3fe85a24
                pipelineCacheUUID[0]:           uint8_t = 5
                pipelineCacheUUID[1]:           uint8_t = 224
                pipelineCacheUUID[2]:           uint8_t = 208
                pipelineCacheUUID[3]:           uint8_t = 207
                pipelineCacheUUID[4]:           uint8_t = 45
                pipelineCacheUUID[5]:           uint8_t = 20
                pipelineCacheUUID[6]:           uint8_t = 165
                pipelineCacheUUID[7]:           uint8_t = 192
                pipelineCacheUUID[8]:           uint8_t = 189
                pipelineCacheUUID[9]:           uint8_t = 96
                pipelineCacheUUID[10]:          uint8_t = 69
                pipelineCacheUUID[11]:          uint8_t = 192
                pipelineCacheUUID[12]:          uint8_t = 238
                pipelineCacheUUID[13]:          uint8_t = 171
                pipelineCacheUUID[14]:          uint8_t = 79
                pipelineCacheUUID[15]:          uint8_t = 66
            limits:                         VkPhysicalDeviceLimits = 0x7fff3fe85a38:
                maxImageDimension1D:            uint32_t = 16384
                maxImageDimension2D:            uint32_t = 16384
                maxImageDimension3D:            uint32_t = 2048
                maxImageDimensionCube:          uint32_t = 16384
                maxImageArrayLayers:            uint32_t = 2048
                maxTexelBufferElements:         uint32_t = 134217728
                maxUniformBufferRange:          uint32_t = 1073741824
                maxStorageBufferRange:          uint32_t = 4294967295
                maxPushConstantsSize:           uint32_t = 128
                maxMemoryAllocationCount:       uint32_t = 4294967295
                maxSamplerAllocationCount:      uint32_t = 65536
                bufferImageGranularity:         VkDeviceSize = 1
                sparseAddressSpaceSize:         VkDeviceSize = 17587891077120
                maxBoundDescriptorSets:         uint32_t = 8
                maxPerStageDescriptorSamplers:  uint32_t = 65535
                maxPerStageDescriptorUniformBuffers: uint32_t = 64
                maxPerStageDescriptorStorageBuffers: uint32_t = 65535
                maxPerStageDescriptorSampledImages: uint32_t = 65535
                maxPerStageDescriptorStorageImages: uint32_t = 65535
                maxPerStageDescriptorInputAttachments: uint32_t = 64
                maxPerStageResources:           uint32_t = 4294967295
                maxDescriptorSetSamplers:       uint32_t = 393210
                maxDescriptorSetUniformBuffers: uint32_t = 384
                maxDescriptorSetUniformBuffersDynamic: uint32_t = 8
                maxDescriptorSetStorageBuffers: uint32_t = 393210
                maxDescriptorSetStorageBuffersDynamic: uint32_t = 8
                maxDescriptorSetSampledImages:  uint32_t = 393210
                maxDescriptorSetStorageImages:  uint32_t = 393210
                maxDescriptorSetInputAttachments: uint32_t = 256
                maxVertexInputAttributes:       uint32_t = 29
                maxVertexInputBindings:         uint32_t = 31
                maxVertexInputAttributeOffset:  uint32_t = 2047
                maxVertexInputBindingStride:    uint32_t = 4095
                maxVertexOutputComponents:      uint32_t = 128
                maxTessellationGenerationLevel: uint32_t = 64
                maxTessellationPatchSize:       uint32_t = 32
                maxTessellationControlPerVertexInputComponents: uint32_t = 128
                maxTessellationControlPerVertexOutputComponents: uint32_t = 128
                maxTessellationControlPerPatchOutputComponents: uint32_t = 128
                maxTessellationControlTotalOutputComponents: uint32_t = 2048
                maxTessellationEvaluationInputComponents: uint32_t = 128
                maxTessellationEvaluationOutputComponents: uint32_t = 128
                maxGeometryShaderInvocations:   uint32_t = 32
                maxGeometryInputComponents:     uint32_t = 128
                maxGeometryOutputComponents:    uint32_t = 128
                maxGeometryOutputVertices:      uint32_t = 256
                maxGeometryTotalOutputComponents: uint32_t = 1024
                maxFragmentInputComponents:     uint32_t = 116
                maxFragmentOutputAttachments:   uint32_t = 8
                maxFragmentDualSrcAttachments:  uint32_t = 1
                maxFragmentCombinedOutputResources: uint32_t = 131078
                maxComputeSharedMemorySize:     uint32_t = 65536
                maxComputeWorkGroupCount:       uint32_t[3] = 0x7fff3fe85b14
                    maxComputeWorkGroupCount[0]:    uint32_t = 65535
                    maxComputeWorkGroupCount[1]:    uint32_t = 65535
                    maxComputeWorkGroupCount[2]:    uint32_t = 65535
                maxComputeWorkGroupInvocations: uint32_t = 1024
                maxComputeWorkGroupSize:        uint32_t[3] = 0x7fff3fe85b24
                    maxComputeWorkGroupSize[0]:     uint32_t = 1024
                    maxComputeWorkGroupSize[1]:     uint32_t = 1024
                    maxComputeWorkGroupSize[2]:     uint32_t = 1024
                subPixelPrecisionBits:          uint32_t = 8
                subTexelPrecisionBits:          uint32_t = 8
                mipmapPrecisionBits:            uint32_t = 8
                maxDrawIndexedIndexValue:       uint32_t = 4294967295
                maxDrawIndirectCount:           uint32_t = 4294967295
                maxSamplerLodBias:              float = 16
                maxSamplerAnisotropy:           float = 16
                maxViewports:                   uint32_t = 16
                maxViewportDimensions:          uint32_t[2] = 0x7fff3fe85b50
                    maxViewportDimensions[0]:       uint32_t = 16384
                    maxViewportDimensions[1]:       uint32_t = 16384
                viewportBoundsRange:            float[2] = 0x7fff3fe85b58
                    viewportBoundsRange[0]:         float = -32768
                    viewportBoundsRange[1]:         float = 32767
                viewportSubPixelBits:           uint32_t = 13
                minMemoryMapAlignment:          size_t = 4096
                minTexelBufferOffsetAlignment:  VkDeviceSize = 16
                minUniformBufferOffsetAlignment: VkDeviceSize = 64
                minStorageBufferOffsetAlignment: VkDeviceSize = 4
                minTexelOffset:                 int32_t = -8
                maxTexelOffset:                 uint32_t = 7
                minTexelGatherOffset:           int32_t = -32
                maxTexelGatherOffset:           uint32_t = 31
                minInterpolationOffset:         float = -0.5
                maxInterpolationOffset:         float = 0.4375
                subPixelInterpolationOffsetBits: uint32_t = 4
                maxFramebufferWidth:            uint32_t = 16384
                maxFramebufferHeight:           uint32_t = 16384
                maxFramebufferLayers:           uint32_t = 2048
                framebufferColorSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferDepthSampleCounts:   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                framebufferNoAttachmentsSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                maxColorAttachments:            uint32_t = 8
                sampledImageColorSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageIntegerSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageDepthSampleCounts:  VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                sampledImageStencilSampleCounts: VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
                storageImageSampleCounts:       VkSampleCountFlags = 1 (VK_SAMPLE_COUNT_1_BIT)
                maxSampleMaskWords:             uint32_t = 1
                timestampComputeAndGraphics:    VkBool32 = 1
                timestampPeriod:                float = 52.0833
                maxClipDistances:               uint32_t = 8
                maxCullDistances:               uint32_t = 8
                maxCombinedClipAndCullDistances: uint32_t = 8
                discreteQueuePriorities:        uint32_t = 2
                pointSizeRange:                 float[2] = 0x7fff3fe85bf4
                    pointSizeRange[0]:              float = 0.125
                    pointSizeRange[1]:              float = 255.875
                lineWidthRange:                 float[2] = 0x7fff3fe85bfc
                    lineWidthRange[0]:              float = 0
                    lineWidthRange[1]:              float = 8
                pointSizeGranularity:           float = 0.125
                lineWidthGranularity:           float = 0.0078125
                strictLines:                    VkBool32 = 0
                standardSampleLocations:        VkBool32 = 1
                optimalBufferCopyOffsetAlignment: VkDeviceSize = 128
                optimalBufferCopyRowPitchAlignment: VkDeviceSize = 128
                nonCoherentAtomSize:            VkDeviceSize = 64
            sparseProperties:               VkPhysicalDeviceSparseProperties = 0x7fff3fe85c30:
                residencyStandard2DBlockShape:  VkBool32 = 1
                residencyStandard2DMultisampleBlockShape: VkBool32 = 0
                residencyStandard3DBlockShape:  VkBool32 = 1
                residencyAlignedMipSize:        VkBool32 = 0
                residencyNonResidentStrict:     VkBool32 = 1
        pNext:                          VkPhysicalDeviceSubgroupProperties = 0x59d134ca89b0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES (1000094000)
            pNext:                          void* = NULL
            subgroupSize:                   uint32_t = 32
            supportedStages:                VkShaderStageFlags = 63 (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT | VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT | VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT | VK_SHADER_STAGE_COMPUTE_BIT)
            supportedOperations:            VkSubgroupFeatureFlags = 255 (VK_SUBGROUP_FEATURE_BASIC_BIT | VK_SUBGROUP_FEATURE_VOTE_BIT | VK_SUBGROUP_FEATURE_ARITHMETIC_BIT | VK_SUBGROUP_FEATURE_BALLOT_BIT | VK_SUBGROUP_FEATURE_SHUFFLE_BIT | VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT | VK_SUBGROUP_FEATURE_CLUSTERED_BIT | VK_SUBGROUP_FEATURE_QUAD_BIT)
            quadOperationsInAllStages:      VkBool32 = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties* = 0x59d134c8faf0
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties = 0x59d134c8faf0:
            queueFlags:                     VkQueueFlags = 31 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT | VK_QUEUE_PROTECTED_BIT)
            queueCount:                     uint32_t = 1
            timestampValidBits:             uint32_t = 36
            minImageTransferGranularity:    VkExtent3D = 0x59d134c8fafc:
                width:                          uint32_t = 1
                height:                         uint32_t = 1
                depth:                          uint32_t = 1

Thread 0, Frame 0:
vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue) returns void:
    device:                         VkDevice = 0x59d134c89710
    queueFamilyIndex:               uint32_t = 0
    queueIndex:                     uint32_t = 0
    pQueue:                         VkQueue* = 0x59d134c8e810

Thread 0, Frame 0:
vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pQueueFamilyPropertyCount:      uint32_t* = 1
    pQueueFamilyProperties:         VkQueueFamilyProperties2* = 0x59d134c8fb10
        pQueueFamilyProperties[0]:      VkQueueFamilyProperties2 = 0x59d134c8fb10:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 (1000059005)
            pNext:                          void* = NULL
            queueFamilyProperties:          VkQueueFamilyProperties = 0x59d134c8fb20:
                queueFlags:                     VkQueueFlags = 31 (VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT | VK_QUEUE_PROTECTED_BIT)
                queueCount:                     uint32_t = 1
                timestampValidBits:             uint32_t = 36
                minImageTransferGranularity:    VkExtent3D = 0x59d134c8fb2c:
                    width:                          uint32_t = 1
                    height:                         uint32_t = 1
                    depth:                          uint32_t = 1

Thread 0, Frame 0:
vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue) returns void:
    device:                         VkDevice = 0x59d134c89710
    queueFamilyIndex:               uint32_t = 0
    queueIndex:                     uint32_t = 0
    pQueue:                         VkQueue* = 0x59d134c8e810

Thread 0, Frame 0:
vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface) returns VkResult VK_SUCCESS (0):
    instance:                       VkInstance = 0x59d134ba5770
    pCreateInfo:                    const VkXcbSurfaceCreateInfoKHR* = 0x7fff3fe86ae0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR (1000005000)
        pNext:                          const void* = NULL
        flags:                          VkXcbSurfaceCreateFlagsKHR = 0
        connection:                     xcb_connection_t* = 0x59d134afe7f0
        window:                         xcb_window_t = 58720265
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSurface:                       VkSurfaceKHR* = 0x59d134c1d0d0

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    queueFamilyIndex:               uint32_t = 0
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSupported:                     VkBool32* = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86a20:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86a28:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86a30:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86a38:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134c913a0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134c913a0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134c913a8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134c913c0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134c913c0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134c913c8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86390:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe863a0:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86560:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    type:                           VkImageType = VK_IMAGE_TYPE_2D (1)
    tiling:                         VkImageTiling = VK_IMAGE_TILING_OPTIMAL (0)
    usage:                          VkImageUsageFlags = 16 (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
    flags:                          VkImageCreateFlags = 0
    pImageFormatProperties:         VkImageFormatProperties* = 0x7fff3fe864a0:
        maxExtent:                      VkExtent3D = 0x7fff3fe864a0:
            width:                          uint32_t = 16384
            height:                         uint32_t = 16384
            depth:                          uint32_t = 1
        maxMipLevels:                   uint32_t = 15
        maxArrayLayers:                 uint32_t = 2048
        sampleCounts:                   VkSampleCountFlags = 31 (VK_SAMPLE_COUNT_1_BIT | VK_SAMPLE_COUNT_2_BIT | VK_SAMPLE_COUNT_4_BIT | VK_SAMPLE_COUNT_8_BIT | VK_SAMPLE_COUNT_16_BIT)
        maxResourceSize:                VkDeviceSize = 17592186044416

Thread 0, Frame 0:
vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkSwapchainCreateInfoKHR* = 0x59d134c919e0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR (1000001000)
        pNext:                          const void* = NULL
        flags:                          VkSwapchainCreateFlagsKHR = 0
        surface:                        VkSurfaceKHR = 0x59d134c1d0d0
        minImageCount:                  uint32_t = 3
        imageFormat:                    VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
        imageColorSpace:                VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        imageExtent:                    VkExtent2D = 0x59d134c91a0c:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        imageArrayLayers:               uint32_t = 1
        imageUsage:                     VkImageUsageFlags = 16 (VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)
        imageSharingMode:               VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 0
        pQueueFamilyIndices:            const uint32_t* = UNUSED
        preTransform:                   VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        compositeAlpha:                 VkCompositeAlphaFlagBitsKHR = 1 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR)
        presentMode:                    VkPresentModeKHR = VK_PRESENT_MODE_FIFO_KHR (2)
        clipped:                        VkBool32 = 1
        oldSwapchain:                   VkSwapchainKHR = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSwapchain:                     VkSwapchainKHR* = 0x59d134c91a50

Thread 0, Frame 0:
vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    pSwapchainImageCount:           uint32_t* = 3
    pSwapchainImages:               VkImage* = NULL

Thread 0, Frame 0:
vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    pSwapchainImageCount:           uint32_t* = 3
    pSwapchainImages:               VkImage* = 0x59d134c90aa0
        pSwapchainImages[0]:            VkImage = 0x59d134c9a150
        pSwapchainImages[1]:            VkImage = 0x59d134c9a830
        pSwapchainImages[2]:            VkImage = 0x59d134c9af40

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86650:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86660:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86670:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86650:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86660:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86670:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86650:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86660:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86670:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134c9dbf0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134c9dbf0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134c9dbf8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86430:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86440:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86520:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkImageViewCreateInfo* = 0x7fff3fe86790:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0x59d134c9a150
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
        components:                     VkComponentMapping = 0x7fff3fe867b8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0x7fff3fe867c8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0x59d134c9dc30

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86680:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86690:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe866a0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134c9db70
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134c9db70:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134c9db78:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86430:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86440:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86520:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkImageViewCreateInfo* = 0x7fff3fe86790:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0x59d134c9a830
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
        components:                     VkComponentMapping = 0x7fff3fe867b8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0x7fff3fe867c8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0x59d134c9e840

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86680:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86690:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe866a0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134c9dbf0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134c9dbf0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134c9dbf8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86430:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86440:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe86520:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateImageView(device, pCreateInfo, pAllocator, pView) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkImageViewCreateInfo* = 0x7fff3fe86790:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (15)
        pNext:                          const void* = NULL
        flags:                          VkImageViewCreateFlags = 0
        image:                          VkImage = 0x59d134c9af40
        viewType:                       VkImageViewType = VK_IMAGE_VIEW_TYPE_2D (1)
        format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
        components:                     VkComponentMapping = 0x7fff3fe867b8:
            r:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            g:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            b:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
            a:                              VkComponentSwizzle = VK_COMPONENT_SWIZZLE_IDENTITY (0)
        subresourceRange:               VkImageSubresourceRange = 0x7fff3fe867c8:
            aspectMask:                     VkImageAspectFlags = 1 (VK_IMAGE_ASPECT_COLOR_BIT)
            baseMipLevel:                   uint32_t = 0
            levelCount:                     uint32_t = 1
            baseArrayLayer:                 uint32_t = 0
            layerCount:                     uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pView:                          VkImageView* = 0x59d134c9f4c0

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe86680:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe86690:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe866a0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkCommandPoolCreateInfo* = 0x7fff3fe86ac0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (39)
        pNext:                          const void* = NULL
        flags:                          VkCommandPoolCreateFlags = 2 (VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)
        queueFamilyIndex:               uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pCommandPool:                   VkCommandPool* = 0x59d134ca02b0

Thread 0, Frame 0:
vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkCommandPoolCreateInfo* = 0x7fff3fe86ac0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (39)
        pNext:                          const void* = NULL
        flags:                          VkCommandPoolCreateFlags = 3 (VK_COMMAND_POOL_CREATE_TRANSIENT_BIT | VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT)
        queueFamilyIndex:               uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pCommandPool:                   VkCommandPool* = 0x59d134c923c0

Thread 0, Frame 0:
vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkShaderModuleCreateInfo* = 0x7fff3fe86820:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (16)
        pNext:                          const void* = NULL
        flags:                          VkShaderModuleCreateFlags = 0
        codeSize:                       size_t = 1044
        pCode:                          const uint32_t* = SHADER DATA
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pShaderModule:                  VkShaderModule* = 0x59d134c93240

Thread 0, Frame 0:
vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkShaderModuleCreateInfo* = 0x7fff3fe86820:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (16)
        pNext:                          const void* = NULL
        flags:                          VkShaderModuleCreateFlags = 0
        codeSize:                       size_t = 568
        pCode:                          const uint32_t* = SHADER DATA
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pShaderModule:                  VkShaderModule* = 0x59d134c943a0

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0x7fff3fe86860:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0x59d134c923c0
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_PRIMARY (0)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0x7fff3fe86b38
        pCommandBuffers[0]:             VkCommandBuffer = 0x59d134cefd30

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0x7fff3fe86860:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0x59d134c923c0
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_SECONDARY (1)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0x7fff3fe86b38
        pCommandBuffers[0]:             VkCommandBuffer = 0x59d134cfcab0

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0x7fff3fe86860:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0x59d134c923c0
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_SECONDARY (1)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0x7fff3fe86b38
        pCommandBuffers[0]:             VkCommandBuffer = 0x59d134d09830

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0x7fff3fe86860:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0x59d134c923c0
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_SECONDARY (1)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0x7fff3fe86b38
        pCommandBuffers[0]:             VkCommandBuffer = 0x59d134d165b0

Thread 0, Frame 0:
vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkBufferCreateInfo* = 0x7fff3fe86790:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (12)
        pNext:                          const void* = NULL
        flags:                          VkBufferCreateFlags = 0
        size:                           VkDeviceSize = 72
        usage:                          VkBufferUsageFlags = 130 (VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 0
        pQueueFamilyIndices:            const uint32_t* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pBuffer:                        VkBuffer* = 0x59d134b2dbb0

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134b2dbb0
    pMemoryRequirements:            VkMemoryRequirements* = 0x59d134ce7538:
        size:                           VkDeviceSize = 72
        alignment:                      VkDeviceSize = 64
        memoryTypeBits:                 uint32_t = 7

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134b2dbb0
    pMemoryRequirements:            VkMemoryRequirements* = 0x7fff3fe86720:
        size:                           VkDeviceSize = 72
        alignment:                      VkDeviceSize = 64
        memoryTypeBits:                 uint32_t = 7

Thread 0, Frame 0:
vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pMemoryProperties:              VkPhysicalDeviceMemoryProperties* = 0x7fff3fe86760:
        memoryTypeCount:                uint32_t = 4
        memoryTypes:                    VkMemoryType[VK_MAX_MEMORY_TYPES] = 0x7fff3fe86764
            memoryTypes[0]:                 VkMemoryType = 0x7fff3fe86764:
                propertyFlags:                  VkMemoryPropertyFlags = 1 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[1]:                 VkMemoryType = 0x7fff3fe8676c:
                propertyFlags:                  VkMemoryPropertyFlags = 7 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[2]:                 VkMemoryType = 0x7fff3fe86774:
                propertyFlags:                  VkMemoryPropertyFlags = 15 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[3]:                 VkMemoryType = 0x7fff3fe8677c:
                propertyFlags:                  VkMemoryPropertyFlags = 33 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_PROTECTED_BIT)
                heapIndex:                      uint32_t = 0
        memoryHeapCount:                uint32_t = 1
        memoryHeaps:                    VkMemoryHeap[VK_MAX_MEMORY_HEAPS] = 0x7fff3fe86868
            memoryHeaps[0]:                 VkMemoryHeap = 0x7fff3fe86868:
                size:                           VkDeviceSize = 12348856320
                flags:                          VkMemoryHeapFlags = 1 (VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0x7fff3fe86540:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 72
        memoryTypeIndex:                uint32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0x59d134cef590

Thread 0, Frame 0:
vkBindBufferMemory(device, buffer, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134b2dbb0
    memory:                         VkDeviceMemory = 0x59d134cef590
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkBufferCreateInfo* = 0x7fff3fe86790:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (12)
        pNext:                          const void* = NULL
        flags:                          VkBufferCreateFlags = 0
        size:                           VkDeviceSize = 72
        usage:                          VkBufferUsageFlags = 1 (VK_BUFFER_USAGE_TRANSFER_SRC_BIT)
        sharingMode:                    VkSharingMode = VK_SHARING_MODE_EXCLUSIVE (0)
        queueFamilyIndexCount:          uint32_t = 0
        pQueueFamilyIndices:            const uint32_t* = UNUSED
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pBuffer:                        VkBuffer* = 0x59d134ce7d30

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134ce7d30
    pMemoryRequirements:            VkMemoryRequirements* = 0x59d134ce8418:
        size:                           VkDeviceSize = 72
        alignment:                      VkDeviceSize = 64
        memoryTypeBits:                 uint32_t = 7

Thread 0, Frame 0:
vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements) returns void:
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134b2dbb0
    pMemoryRequirements:            VkMemoryRequirements* = 0x7fff3fe86720:
        size:                           VkDeviceSize = 72
        alignment:                      VkDeviceSize = 64
        memoryTypeBits:                 uint32_t = 7

Thread 0, Frame 0:
vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    pMemoryProperties:              VkPhysicalDeviceMemoryProperties* = 0x7fff3fe86760:
        memoryTypeCount:                uint32_t = 4
        memoryTypes:                    VkMemoryType[VK_MAX_MEMORY_TYPES] = 0x7fff3fe86764
            memoryTypes[0]:                 VkMemoryType = 0x7fff3fe86764:
                propertyFlags:                  VkMemoryPropertyFlags = 1 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[1]:                 VkMemoryType = 0x7fff3fe8676c:
                propertyFlags:                  VkMemoryPropertyFlags = 7 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[2]:                 VkMemoryType = 0x7fff3fe86774:
                propertyFlags:                  VkMemoryPropertyFlags = 15 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
                heapIndex:                      uint32_t = 0
            memoryTypes[3]:                 VkMemoryType = 0x7fff3fe8677c:
                propertyFlags:                  VkMemoryPropertyFlags = 33 (VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_PROTECTED_BIT)
                heapIndex:                      uint32_t = 0
        memoryHeapCount:                uint32_t = 1
        memoryHeaps:                    VkMemoryHeap[VK_MAX_MEMORY_HEAPS] = 0x7fff3fe86868
            memoryHeaps[0]:                 VkMemoryHeap = 0x7fff3fe86868:
                size:                           VkDeviceSize = 12348856320
                flags:                          VkMemoryHeapFlags = 1 (VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)

Thread 0, Frame 0:
vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkMemoryAllocateInfo* = 0x7fff3fe86540:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (5)
        pNext:                          const void* = NULL
        allocationSize:                 VkDeviceSize = 72
        memoryTypeIndex:                uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pMemory:                        VkDeviceMemory* = 0x59d134cef1e0

Thread 0, Frame 0:
vkBindBufferMemory(device, buffer, memory, memoryOffset) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134ce7d30
    memory:                         VkDeviceMemory = 0x59d134cef1e0
    memoryOffset:                   VkDeviceSize = 0

Thread 0, Frame 0:
vkMapMemory(device, memory, offset, size, flags, ppData) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    memory:                         VkDeviceMemory = 0x59d134cef1e0
    offset:                         VkDeviceSize = 0
    size:                           VkDeviceSize = 72
    flags:                          VkMemoryMapFlags = 0
    ppData:                         void** = 0x753c369f6000

Thread 0, Frame 0:
vkUnmapMemory(device, memory) returns void:
    device:                         VkDevice = 0x59d134c89710
    memory:                         VkDeviceMemory = 0x59d134cef1e0

Thread 0, Frame 0:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d165b0
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 0:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d165b0
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe867c0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 1 (VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT)
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = 0x59d134ce8e40:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO (41)
            pNext:                          const void* = NULL
            renderPass:                     VkRenderPass = 0
            subpass:                        uint32_t = 0
            framebuffer:                    VkFramebuffer = 0
            occlusionQueryEnable:           VkBool32 = 0
            queryFlags:                     VkQueryControlFlags = 0
            pipelineStatistics:             VkQueryPipelineStatisticFlags = 0

Thread 0, Frame 0:
vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d165b0
    srcBuffer:                      VkBuffer = 0x59d134ce7d30
    dstBuffer:                      VkBuffer = 0x59d134b2dbb0
    regionCount:                    uint32_t = 1
    pRegions:                       const VkBufferCopy* = 0x7fff3fe86a10
        pRegions[0]:                    const VkBufferCopy = 0x7fff3fe86a10:
            srcOffset:                      VkDeviceSize = 0
            dstOffset:                      VkDeviceSize = 0
            size:                           VkDeviceSize = 72

Thread 0, Frame 0:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d165b0

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = NULL

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceFormatCount:            uint32_t* = 2
    pSurfaceFormats:                VkSurfaceFormatKHR* = 0x59d134cecfd0
        pSurfaceFormats[0]:             VkSurfaceFormatKHR = 0x59d134cecfd0:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)
        pSurfaceFormats[1]:             VkSurfaceFormatKHR = 0x59d134cecfd8:
            format:                         VkFormat = VK_FORMAT_B8G8R8A8_UNORM (44)
            colorSpace:                     VkColorSpaceKHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (0)

Thread 0, Frame 0:
vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkPipelineLayoutCreateInfo* = 0x7fff3fe86550:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO (30)
        pNext:                          const void* = NULL
        flags:                          VkPipelineLayoutCreateFlags = 0
        setLayoutCount:                 uint32_t = 0
        pSetLayouts:                    const VkDescriptorSetLayout* = NULL
        pushConstantRangeCount:         uint32_t = 0
        pPushConstantRanges:            const VkPushConstantRange* = NULL
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pPipelineLayout:                VkPipelineLayout* = 0x59d134ce99b0

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe85d80:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe85d90:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe85da0:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkRenderPassCreateInfo* = 0x7fff3fe86b30:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO (38)
        pNext:                          const void* = NULL
        flags:                          VkRenderPassCreateFlags = 0
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkAttachmentDescription* = 0x7fff3fe86cb0
            pAttachments[0]:                const VkAttachmentDescription = 0x7fff3fe86cb0:
                flags:                          VkAttachmentDescriptionFlags = 0
                format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
                samples:                        VkSampleCountFlagBits = 1 (VK_SAMPLE_COUNT_1_BIT)
                loadOp:                         VkAttachmentLoadOp = VK_ATTACHMENT_LOAD_OP_CLEAR (1)
                storeOp:                        VkAttachmentStoreOp = VK_ATTACHMENT_STORE_OP_STORE (0)
                stencilLoadOp:                  VkAttachmentLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE (2)
                stencilStoreOp:                 VkAttachmentStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE (1)
                initialLayout:                  VkImageLayout = VK_IMAGE_LAYOUT_UNDEFINED (0)
                finalLayout:                    VkImageLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR (1000001002)
        subpassCount:                   uint32_t = 1
        pSubpasses:                     const VkSubpassDescription* = 0x7fff3fe86e30
            pSubpasses[0]:                  const VkSubpassDescription = 0x7fff3fe86e30:
                flags:                          VkSubpassDescriptionFlags = 0
                pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
                inputAttachmentCount:           uint32_t = 0
                pInputAttachments:              const VkAttachmentReference* = NULL
                colorAttachmentCount:           uint32_t = 1
                pColorAttachments:              const VkAttachmentReference* = 0x7fff3fe86bbc
                    pColorAttachments[0]:           const VkAttachmentReference = 0x7fff3fe86bbc:
                        attachment:                     uint32_t = 0
                        layout:                         VkImageLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL (2)
                pResolveAttachments:            const VkAttachmentReference* = NULL
                pDepthStencilAttachment:        const VkAttachmentReference* = NULL
                preserveAttachmentCount:        uint32_t = 0
                pPreserveAttachments:           const uint32_t* = NULL
        dependencyCount:                uint32_t = 1
        pDependencies:                  const VkSubpassDependency* = 0x7fff3fe86c50
            pDependencies[0]:               const VkSubpassDependency = 0x7fff3fe86c50:
                srcSubpass:                     uint32_t = 4294967295
                dstSubpass:                     uint32_t = 0
                srcStageMask:                   VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
                dstStageMask:                   VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
                srcAccessMask:                  VkAccessFlags = 0 (VK_ACCESS_NONE)
                dstAccessMask:                  VkAccessFlags = 256 (VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT)
                dependencyFlags:                VkDependencyFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pRenderPass:                    VkRenderPass* = 0x59d134b51170

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_R32G32B32_SFLOAT (106)
    pFormatProperties:              VkFormatProperties* = 0x7fff3fe85e84:
        linearTilingFeatures:           VkFormatFeatureFlags = 119809 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
        optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
        bufferFeatures:                 VkFormatFeatureFlags = 72 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT | VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_R32G32B32_SFLOAT (106)
    pFormatProperties:              VkFormatProperties* = 0x7fff3fe85e84:
        linearTilingFeatures:           VkFormatFeatureFlags = 119809 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
        optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
        bufferFeatures:                 VkFormatFeatureFlags = 72 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT | VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties) returns void:
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    format:                         VkFormat = VK_FORMAT_B8G8R8A8_SRGB (50)
    pFormatProperties:              VkFormatProperties2* = 0x7fff3fe85ef0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (1000059002)
        pNext:                          void* = VkFormatProperties3
        formatProperties:               VkFormatProperties = 0x7fff3fe85f00:
            linearTilingFeatures:           VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags = 122241 (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_BLIT_SRC_BIT | VK_FORMAT_FEATURE_BLIT_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags = 8 (VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT)
        pNext:                          VkFormatProperties3 = 0x7fff3fe85f10:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3 (1000360000)
            pNext:                          void* = NULL
            linearTilingFeatures:           VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            optimalTilingFeatures:          VkFormatFeatureFlags2 = 122241 (VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT | VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT | VK_FORMAT_FEATURE_2_BLIT_SRC_BIT | VK_FORMAT_FEATURE_2_BLIT_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT | VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT | VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT | VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT)
            bufferFeatures:                 VkFormatFeatureFlags2 = 8 (VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT)

Thread 0, Frame 0:
vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pipelineCache:                  VkPipelineCache = 0
    createInfoCount:                uint32_t = 1
    pCreateInfos:                   const VkGraphicsPipelineCreateInfo* = 0x59d134bea128
        pCreateInfos[0]:                const VkGraphicsPipelineCreateInfo = 0x59d134bea128:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO (28)
            pNext:                          const void* = NULL
            flags:                          VkPipelineCreateFlags = 0
            stageCount:                     uint32_t = 2
            pStages:                        const VkPipelineShaderStageCreateInfo* = 0x59d134cef8e8
                pStages[0]:                     const VkPipelineShaderStageCreateInfo = 0x59d134cef8e8:
                    sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (18)
                    pNext:                          const void* = NULL
                    flags:                          VkPipelineShaderStageCreateFlags = 0
                    stage:                          VkShaderStageFlagBits = 1 (VK_SHADER_STAGE_VERTEX_BIT)
                    module:                         VkShaderModule = 0x59d134c93240
                    pName:                          const char* = "main"
                    pSpecializationInfo:            const VkSpecializationInfo* = NULL
                pStages[1]:                     const VkPipelineShaderStageCreateInfo = 0x59d134cef918:
                    sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (18)
                    pNext:                          const void* = NULL
                    flags:                          VkPipelineShaderStageCreateFlags = 0
                    stage:                          VkShaderStageFlagBits = 16 (VK_SHADER_STAGE_FRAGMENT_BIT)
                    module:                         VkShaderModule = 0x59d134c943a0
                    pName:                          const char* = "main"
                    pSpecializationInfo:            const VkSpecializationInfo* = NULL
            pVertexInputState:              const VkPipelineVertexInputStateCreateInfo* = 0x59d134cebfd0:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO (19)
                pNext:                          const void* = NULL
                flags:                          VkPipelineVertexInputStateCreateFlags = 0
                vertexBindingDescriptionCount:  uint32_t = 1
                pVertexBindingDescriptions:     const VkVertexInputBindingDescription* = 0x59d134cec3e0
                    pVertexBindingDescriptions[0]:  const VkVertexInputBindingDescription = 0x59d134cec3e0:
                        binding:                        uint32_t = 0
                        stride:                         uint32_t = 24
                        inputRate:                      VkVertexInputRate = VK_VERTEX_INPUT_RATE_VERTEX (0)
                vertexAttributeDescriptionCount: uint32_t = 2
                pVertexAttributeDescriptions:   const VkVertexInputAttributeDescription* = 0x59d134ce9110
                    pVertexAttributeDescriptions[0]: const VkVertexInputAttributeDescription = 0x59d134ce9110:
                        location:                       uint32_t = 0
                        binding:                        uint32_t = 0
                        format:                         VkFormat = VK_FORMAT_R32G32B32_SFLOAT (106)
                        offset:                         uint32_t = 0
                    pVertexAttributeDescriptions[1]: const VkVertexInputAttributeDescription = 0x59d134ce9120:
                        location:                       uint32_t = 1
                        binding:                        uint32_t = 0
                        format:                         VkFormat = VK_FORMAT_R32G32B32_SFLOAT (106)
                        offset:                         uint32_t = 12
            pInputAssemblyState:            const VkPipelineInputAssemblyStateCreateInfo* = 0x59d134ce9260:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO (20)
                pNext:                          const void* = NULL
                flags:                          VkPipelineInputAssemblyStateCreateFlags = 0
                topology:                       VkPrimitiveTopology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST (3)
                primitiveRestartEnable:         VkBool32 = 0
            pTessellationState:             const VkPipelineTessellationStateCreateInfo* = NULL
            pViewportState:                 const VkPipelineViewportStateCreateInfo* = 0x59d134cec010:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO (22)
                pNext:                          const void* = NULL
                flags:                          VkPipelineViewportStateCreateFlags = 0
                viewportCount:                  uint32_t = 1
                pViewports:                     const VkViewport* = UNUSED
                scissorCount:                   uint32_t = 1
                pScissors:                      const VkRect2D* = UNUSED
            pRasterizationState:            const VkPipelineRasterizationStateCreateInfo* = 0x59d134cebef0:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO (23)
                pNext:                          const void* = NULL
                flags:                          VkPipelineRasterizationStateCreateFlags = 0
                depthClampEnable:               VkBool32 = 0
                rasterizerDiscardEnable:        VkBool32 = 0
                polygonMode:                    VkPolygonMode = VK_POLYGON_MODE_FILL (0)
                cullMode:                       VkCullModeFlags = 2 (VK_CULL_MODE_BACK_BIT)
                frontFace:                      VkFrontFace = VK_FRONT_FACE_CLOCKWISE (1)
                depthBiasEnable:                VkBool32 = 0
                depthBiasConstantFactor:        float = 0
                depthBiasClamp:                 float = 0
                depthBiasSlopeFactor:           float = 0
                lineWidth:                      float = 1
            pMultisampleState:              const VkPipelineMultisampleStateCreateInfo* = 0x59d134cec050:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO (24)
                pNext:                          const void* = NULL
                flags:                          VkPipelineMultisampleStateCreateFlags = 0
                rasterizationSamples:           VkSampleCountFlagBits = 1 (VK_SAMPLE_COUNT_1_BIT)
                sampleShadingEnable:            VkBool32 = 0
                minSampleShading:               float = 0
                pSampleMask:                    const VkSampleMask* = NULL
                alphaToCoverageEnable:          VkBool32 = 0
                alphaToOneEnable:               VkBool32 = 0
            pDepthStencilState:             const VkPipelineDepthStencilStateCreateInfo* = NULL
            pColorBlendState:               const VkPipelineColorBlendStateCreateInfo* = 0x59d134cec400:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO (26)
                pNext:                          const void* = NULL
                flags:                          VkPipelineColorBlendStateCreateFlags = 0
                logicOpEnable:                  VkBool32 = 0
                logicOp:                        VkLogicOp = VK_LOGIC_OP_CLEAR (0)
                attachmentCount:                uint32_t = 1
                pAttachments:                   const VkPipelineColorBlendAttachmentState* = 0x59d134ce9200
                    pAttachments[0]:                const VkPipelineColorBlendAttachmentState = 0x59d134ce9200:
                        blendEnable:                    VkBool32 = 0
                        srcColorBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        dstColorBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        colorBlendOp:                   VkBlendOp = VK_BLEND_OP_ADD (0)
                        srcAlphaBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        dstAlphaBlendFactor:            VkBlendFactor = VK_BLEND_FACTOR_ZERO (0)
                        alphaBlendOp:                   VkBlendOp = VK_BLEND_OP_ADD (0)
                        colorWriteMask:                 VkColorComponentFlags = 15 (VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT)
                blendConstants:                 float[4] = 0x59d134cec428
                    blendConstants[0]:              float = 0
                    blendConstants[1]:              float = 0
                    blendConstants[2]:              float = 0
                    blendConstants[3]:              float = 0
            pDynamicState:                  const VkPipelineDynamicStateCreateInfo* = 0x59d134ce9230:
                sType:                          VkStructureType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO (27)
                pNext:                          const void* = NULL
                flags:                          VkPipelineDynamicStateCreateFlags = 0
                dynamicStateCount:              uint32_t = 2
                pDynamicStates:                 const VkDynamicState* = 0x59d134cec440
                    pDynamicStates[0]:              const VkDynamicState = VK_DYNAMIC_STATE_VIEWPORT (0)
                    pDynamicStates[1]:              const VkDynamicState = VK_DYNAMIC_STATE_SCISSOR (1)
            layout:                         VkPipelineLayout = 0x59d134ce99b0
            renderPass:                     VkRenderPass = 0x59d134b51170
            subpass:                        uint32_t = 0
            basePipelineHandle:             VkPipeline = 0
            basePipelineIndex:              int32_t = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pPipelines:                     VkPipeline* = 0x7fff3fe86d70
        pPipelines[0]:                  VkPipeline = 0x59d134d23330

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0x7fff3fe865a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0x59d134b51170
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0x59d134cec440
            pAttachments[0]:                const VkImageView = 0x59d134c9dc30
        width:                          uint32_t = 1920
        height:                         uint32_t = 1080
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0x59d134c984f0

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0x7fff3fe865a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0x59d134b51170
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0x59d134cec3e0
            pAttachments[0]:                const VkImageView = 0x59d134c9e840
        width:                          uint32_t = 1920
        height:                         uint32_t = 1080
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0x59d134c92510

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe86710:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe86718:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe86720:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe86728:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkFramebufferCreateInfo* = 0x7fff3fe865a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (37)
        pNext:                          const void* = NULL
        flags:                          VkFramebufferCreateFlags = 0
        renderPass:                     VkRenderPass = 0x59d134b51170
        attachmentCount:                uint32_t = 1
        pAttachments:                   const VkImageView* = 0x59d134cec3a0
            pAttachments[0]:                const VkImageView = 0x59d134c9f4c0
        width:                          uint32_t = 1920
        height:                         uint32_t = 1080
        layers:                         uint32_t = 1
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFramebuffer:                   VkFramebuffer* = 0x59d134c9b910

Thread 0, Frame 0:
vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pAllocateInfo:                  const VkCommandBufferAllocateInfo* = 0x7fff3fe86940:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (40)
        pNext:                          const void* = NULL
        commandPool:                    VkCommandPool = 0x59d134ca02b0
        level:                          VkCommandBufferLevel = VK_COMMAND_BUFFER_LEVEL_PRIMARY (0)
        commandBufferCount:             uint32_t = 1
    pCommandBuffers:                VkCommandBuffer* = 0x7fff3fe86ca8
        pCommandBuffers[0]:             VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 0:
vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkSemaphoreCreateInfo* = 0x7fff3fe86c10:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (9)
        pNext:                          const void* = NULL
        flags:                          VkSemaphoreCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSemaphore:                     VkSemaphore* = 0x59d134bdaaa0

Thread 0, Frame 0:
vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkSemaphoreCreateInfo* = 0x7fff3fe86c10:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (9)
        pNext:                          const void* = NULL
        flags:                          VkSemaphoreCreateFlags = 0
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pSemaphore:                     VkSemaphore* = 0x59d134ba91e0

Thread 0, Frame 0:
vkCreateFence(device, pCreateInfo, pAllocator, pFence) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    pCreateInfo:                    const VkFenceCreateInfo* = 0x7fff3fe86c30:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (8)
        pNext:                          const void* = NULL
        flags:                          VkFenceCreateFlags = 1 (VK_FENCE_CREATE_SIGNALED_BIT)
    pAllocator:                     const VkAllocationCallbacks* = NULL
    pFence:                         VkFence* = 0x59d134c919e0

Thread 0, Frame 0:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 0:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 0:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 0:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 0:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d34be0
            pClearValues[0]:                const VkClearValue = 0x59d134d34be0 (Union):
                color:                          VkClearColorValue = 0x59d134d34be0 (Union):
                    float32:                        float[4] = 0x59d134d34be0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d34be0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d34be0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d34be0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 0:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 0:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 0:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 0:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 0:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 0:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 0:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 0:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x59d134cee9b8
        pSubmits[0]:                    const VkSubmitInfo = 0x59d134cee9b8:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d372f0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d37310
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37330
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37350
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 0:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d34c90:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37350
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37330
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d37310
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 1:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134cefd30
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 1:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134cefd30
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86a60:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 1:
vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134cefd30
    commandBufferCount:             uint32_t = 1
    pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37350
        pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134cfcab0

Thread 0, Frame 1:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134cefd30

Thread 0, Frame 1:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x59d134cee9b8
        pSubmits[0]:                    const VkSubmitInfo = 0x59d134cee9b8:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 0
            pWaitSemaphores:                const VkSemaphore* = NULL
            pWaitDstStageMask:              const VkPipelineStageFlags* = NULL
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c1d570
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134cefd30
            signalSemaphoreCount:           uint32_t = 0
            pSignalSemaphores:              const VkSemaphore* = NULL
    fence:                          VkFence = 0

Thread 0, Frame 1:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 1:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 1:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 1:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 1:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 1:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 1:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce9110
            pClearValues[0]:                const VkClearValue = 0x59d134ce9110 (Union):
                color:                          VkClearColorValue = 0x59d134ce9110 (Union):
                    float32:                        float[4] = 0x59d134ce9110
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce9110
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce9110
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce9110:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 1:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 1:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 1:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 1:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 1:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 1:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 1:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 1:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 1:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 1:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 1:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceede0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceee00
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceee20
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 1:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceee20
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceee00
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceede0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 2:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 2:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 2:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 2:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 2:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 2:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 2:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 2:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 2:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 2:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 2:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 2:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 2:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 2:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 2:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 2:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 2:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 2:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c752b0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef510
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef530
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 2:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef530
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d37310
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 3:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 3:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 3:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 3:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 3:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 3:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 3:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceee20
            pClearValues[0]:                const VkClearValue = 0x59d134ceee20 (Union):
                color:                          VkClearColorValue = 0x59d134ceee20 (Union):
                    float32:                        float[4] = 0x59d134ceee20
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceee20
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceee20
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceee20:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 3:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 3:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 3:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 3:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 3:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 3:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 3:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 3:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 3:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 3:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 3:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c38bb0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 3:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 4:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 4:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 4:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 4:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 4:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 4:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 4:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 4:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 4:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 4:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 4:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 4:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 4:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 4:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 4:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c38bb0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 4:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c38bb0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c90a50
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 5:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 5:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 5:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 5:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 5:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 5:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 5:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 5:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 5:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 5:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 5:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 5:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 5:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 5:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 5:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 5:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 6:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 6:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 6:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 6:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 6:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 6:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 6:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef530
            pClearValues[0]:                const VkClearValue = 0x59d134cef530 (Union):
                color:                          VkClearColorValue = 0x59d134cef530 (Union):
                    float32:                        float[4] = 0x59d134cef530
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef530
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef530
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef530:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 6:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 6:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 6:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 6:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 6:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 6:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 6:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 6:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 6:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 6:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 6:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceee20
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 6:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceee20
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 7:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 7:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 7:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 7:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 7:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 7:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 7:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d37310
            pClearValues[0]:                const VkClearValue = 0x59d134d37310 (Union):
                color:                          VkClearColorValue = 0x59d134d37310 (Union):
                    float32:                        float[4] = 0x59d134d37310
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d37310
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d37310
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d37310:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 7:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 7:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 7:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 7:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 7:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 7:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 7:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 7:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 7:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 7:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 7:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceede0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 7:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceede0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceedc0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 8:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 8:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 8:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 8:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 8:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 8:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 8:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 8:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 8:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 8:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 8:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 8:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 8:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 8:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 8:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 8:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 8:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 8:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceedc0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 8:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 9:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 9:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 9:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 9:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 9:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 9:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 9:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef510
            pClearValues[0]:                const VkClearValue = 0x59d134cef510 (Union):
                color:                          VkClearColorValue = 0x59d134cef510 (Union):
                    float32:                        float[4] = 0x59d134cef510
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef510
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef510
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef510:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 9:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 9:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 9:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 9:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 9:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 9:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 9:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 9:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 9:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 9:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 9:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 9:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 10:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 10:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 10:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 10:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 10:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 10:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 10:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 10:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 10:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 10:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 10:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 10:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 10:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 10:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 10:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 10:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 10:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 10:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c90a50
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef530
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 10:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef530
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 11:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 11:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 11:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 11:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 11:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 11:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 11:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 11:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 11:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 11:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 11:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 11:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 11:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 11:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 11:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 11:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 11:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 11:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef510
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d35960
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 11:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 12:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 12:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 12:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 12:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 12:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 12:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 12:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 12:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 12:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 12:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 12:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 12:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 12:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 12:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 12:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 12:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 12:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 12:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 12:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 13:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 13:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 13:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 13:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 13:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 13:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 13:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef510
            pClearValues[0]:                const VkClearValue = 0x59d134cef510 (Union):
                color:                          VkClearColorValue = 0x59d134cef510 (Union):
                    float32:                        float[4] = 0x59d134cef510
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef510
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef510
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef510:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 13:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 13:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 13:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 13:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 13:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 13:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 13:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 13:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 13:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 13:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 13:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 13:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef510
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 14:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 14:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 14:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 14:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 14:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 14:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 14:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef530
            pClearValues[0]:                const VkClearValue = 0x59d134cef530 (Union):
                color:                          VkClearColorValue = 0x59d134cef530 (Union):
                    float32:                        float[4] = 0x59d134cef530
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef530
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef530
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef530:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 14:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 14:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 14:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 14:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 14:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 14:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 14:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 14:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 14:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 14:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 14:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 14:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 15:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 15:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 15:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 15:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 15:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 15:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 15:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef510
            pClearValues[0]:                const VkClearValue = 0x59d134cef510 (Union):
                color:                          VkClearColorValue = 0x59d134cef510 (Union):
                    float32:                        float[4] = 0x59d134cef510
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef510
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef510
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef510:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 15:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 15:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 15:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 15:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 15:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 15:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 15:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 15:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 15:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 15:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 15:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceee20
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 15:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceee20
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 16:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 16:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 16:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 16:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 16:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 16:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 16:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 16:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 16:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 16:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 16:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 16:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 16:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 16:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 16:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 16:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 16:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 16:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d35960
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 16:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 17:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 17:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 17:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 17:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 17:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 17:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 17:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 17:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 17:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 17:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 17:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 17:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 17:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 17:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 17:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 17:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 17:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 17:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 17:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 18:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 18:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 18:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 18:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 18:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 18:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 18:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 18:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 18:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 18:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 18:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 18:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 18:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 18:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 18:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 18:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 18:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 18:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 18:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 19:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 19:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 19:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 19:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 19:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 19:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 19:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 19:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 19:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 19:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 19:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 19:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 19:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 19:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 19:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 19:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 19:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 19:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef530
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 19:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef530
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 20:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 20:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 20:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 20:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 20:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 20:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 20:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 20:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 20:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 20:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 20:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 20:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 20:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 20:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 20:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 20:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 20:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 20:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 20:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 21:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 21:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 21:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 21:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 21:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 21:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 21:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 21:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 21:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 21:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 21:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 21:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 21:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 21:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 21:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 21:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 21:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 21:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 21:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 22:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 22:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 22:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 22:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 22:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 22:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 22:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 22:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 22:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 22:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 22:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 22:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 22:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 22:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 22:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 22:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 22:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 22:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c90a50
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceede0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 22:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceede0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 23:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 23:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 23:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 23:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 23:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 23:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 23:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 23:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 23:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 23:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 23:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 23:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 23:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 23:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 23:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 23:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 23:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 23:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 23:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c90a50
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 24:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 24:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 24:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 24:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 24:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 24:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 24:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 24:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 24:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 24:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 24:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 24:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 24:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 24:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 24:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 24:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 24:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 24:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceea10
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 24:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea10
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 25:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 25:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 25:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 25:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 25:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 25:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 25:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 25:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 25:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 25:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 25:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 25:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 25:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 25:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 25:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 25:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 25:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 25:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceedc0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 25:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 26:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 26:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 26:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 26:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 26:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 26:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 26:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 26:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 26:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 26:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 26:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 26:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 26:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 26:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 26:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 26:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 26:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 26:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceedc0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 26:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 27:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 27:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 27:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 27:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 27:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 27:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 27:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 27:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 27:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 27:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 27:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 27:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 27:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 27:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 27:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 27:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 27:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 27:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceea70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 27:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 28:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 28:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 28:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 28:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 28:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 28:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 28:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 28:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 28:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 28:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 28:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 28:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 28:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 28:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 28:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 28:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 28:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 28:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceea70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 28:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 29:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 29:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 29:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 29:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 29:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 29:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 29:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea70
            pClearValues[0]:                const VkClearValue = 0x59d134ceea70 (Union):
                color:                          VkClearColorValue = 0x59d134ceea70 (Union):
                    float32:                        float[4] = 0x59d134ceea70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 29:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 29:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 29:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 29:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 29:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 29:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 29:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 29:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 29:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 29:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 29:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceea10
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 29:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea10
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceea70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 30:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 30:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 30:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 30:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 30:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 30:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 30:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 30:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 30:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 30:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 30:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 30:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 30:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 30:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 30:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 30:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 30:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 30:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 30:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 31:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 31:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 31:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 31:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 31:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 31:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 31:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea70
            pClearValues[0]:                const VkClearValue = 0x59d134ceea70 (Union):
                color:                          VkClearColorValue = 0x59d134ceea70 (Union):
                    float32:                        float[4] = 0x59d134ceea70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 31:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 31:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 31:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 31:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 31:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 31:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 31:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 31:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 31:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 31:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 31:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 31:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 32:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 32:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 32:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 32:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 32:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 32:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 32:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 32:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 32:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 32:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 32:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 32:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 32:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 32:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 32:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 32:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 32:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 32:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d35960
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceede0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 32:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceede0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 33:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 33:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 33:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 33:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 33:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 33:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 33:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 33:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 33:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 33:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 33:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 33:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 33:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 33:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 33:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 33:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 33:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 33:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 33:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 34:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 34:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 34:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 34:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 34:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 34:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 34:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 34:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 34:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 34:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 34:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 34:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 34:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 34:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 34:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 34:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 34:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 34:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef430
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 34:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef430
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 35:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 35:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 35:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 35:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 35:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 35:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 35:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 35:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 35:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 35:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 35:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 35:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 35:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 35:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 35:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 35:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 35:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 35:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceedc0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 35:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 36:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 36:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 36:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 36:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 36:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 36:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 36:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 36:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 36:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 36:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 36:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 36:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 36:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 36:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 36:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 36:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 36:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 36:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceedc0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 36:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 37:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 37:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 37:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 37:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 37:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 37:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 37:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 37:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 37:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 37:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 37:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 37:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 37:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 37:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 37:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 37:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 37:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 37:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef490
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d35960
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 37:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef490
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 38:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 38:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 38:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 38:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 38:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 38:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 38:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 38:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 38:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 38:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 38:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 38:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 38:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 38:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 38:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 38:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 38:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 38:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef490
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 38:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef490
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 39:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 39:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 39:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 39:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 39:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 39:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 39:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef490
            pClearValues[0]:                const VkClearValue = 0x59d134cef490 (Union):
                color:                          VkClearColorValue = 0x59d134cef490 (Union):
                    float32:                        float[4] = 0x59d134cef490
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef490
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef490
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef490:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 39:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 39:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 39:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 39:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 39:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 39:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 39:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 39:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 39:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 39:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 39:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef490
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef430
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 39:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef430
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef490
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 40:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 40:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 40:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 40:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 40:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 40:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 40:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d37310
            pClearValues[0]:                const VkClearValue = 0x59d134d37310 (Union):
                color:                          VkClearColorValue = 0x59d134d37310 (Union):
                    float32:                        float[4] = 0x59d134d37310
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d37310
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d37310
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d37310:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 40:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 40:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 40:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 40:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 40:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 40:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 40:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 40:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 40:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 40:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 40:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 40:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 41:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 41:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 41:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 41:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 41:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 41:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 41:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef490
            pClearValues[0]:                const VkClearValue = 0x59d134cef490 (Union):
                color:                          VkClearColorValue = 0x59d134cef490 (Union):
                    float32:                        float[4] = 0x59d134cef490
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef490
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef490
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef490:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 41:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 41:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 41:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 41:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 41:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 41:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 41:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 41:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 41:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 41:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 41:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef490
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d35960
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 41:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37310
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 42:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 42:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 42:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 42:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 42:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 42:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 42:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 42:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 42:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 42:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 42:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 42:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 42:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 42:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 42:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 42:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 42:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 42:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d37310
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceede0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 42:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceede0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37310
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 43:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 43:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 43:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 43:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 43:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 43:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 43:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d37310
            pClearValues[0]:                const VkClearValue = 0x59d134d37310 (Union):
                color:                          VkClearColorValue = 0x59d134d37310 (Union):
                    float32:                        float[4] = 0x59d134d37310
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d37310
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d37310
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d37310:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 43:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 43:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 43:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 43:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 43:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 43:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 43:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 43:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 43:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 43:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 43:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 43:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d37310
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 44:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 44:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 44:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 44:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 44:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 44:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 44:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 44:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 44:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 44:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 44:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 44:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 44:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 44:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 44:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 44:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 44:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 44:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 44:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 45:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 45:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 45:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 45:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 45:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 45:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 45:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d37310
            pClearValues[0]:                const VkClearValue = 0x59d134d37310 (Union):
                color:                          VkClearColorValue = 0x59d134d37310 (Union):
                    float32:                        float[4] = 0x59d134d37310
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d37310
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d37310
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d37310:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 45:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 45:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 45:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 45:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 45:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 45:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 45:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 45:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 45:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 45:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 45:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceedc0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d35960
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 45:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 46:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 46:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 46:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 46:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 46:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 46:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 46:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 46:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 46:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 46:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 46:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 46:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 46:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 46:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 46:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 46:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 46:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 46:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceedc0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 46:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 47:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 47:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 47:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 47:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 47:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 47:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 47:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 47:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 47:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 47:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 47:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 47:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 47:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 47:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 47:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 47:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 47:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 47:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef570
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 47:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef570
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 48:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 48:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 48:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 48:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 48:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 48:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 48:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 48:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 48:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 48:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 48:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 48:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 48:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 48:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 48:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 48:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 48:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 48:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef570
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 48:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef570
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 49:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 49:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 49:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 49:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 49:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 49:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 49:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef570
            pClearValues[0]:                const VkClearValue = 0x59d134cef570 (Union):
                color:                          VkClearColorValue = 0x59d134cef570 (Union):
                    float32:                        float[4] = 0x59d134cef570
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef570
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef570
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef570:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 49:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 49:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 49:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 49:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 49:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 49:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 49:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 49:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 49:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 49:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 49:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef570
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 49:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef570
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 50:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 50:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 50:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 50:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 50:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 50:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 50:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 50:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 50:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 50:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 50:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 50:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 50:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 50:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 50:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 50:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 50:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 50:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 50:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 51:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 51:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 51:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 51:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 51:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 51:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 51:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef570
            pClearValues[0]:                const VkClearValue = 0x59d134cef570 (Union):
                color:                          VkClearColorValue = 0x59d134cef570 (Union):
                    float32:                        float[4] = 0x59d134cef570
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef570
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef570
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef570:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 51:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 51:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 51:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 51:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 51:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 51:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 51:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 51:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 51:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 51:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 51:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134cef570
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 51:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 52:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 52:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 52:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 52:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 52:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 52:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 52:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 52:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 52:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 52:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 52:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 52:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 52:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 52:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 52:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 52:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 52:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 52:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c90a50
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceede0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 52:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceede0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 53:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 53:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 53:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 53:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 53:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 53:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 53:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 53:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 53:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 53:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 53:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 53:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 53:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 53:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 53:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 53:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 53:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 53:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 53:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c90a50
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 54:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 54:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 54:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 54:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 54:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 54:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 54:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 54:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 54:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 54:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 54:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 54:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 54:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 54:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 54:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 54:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 54:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 54:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceea10
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 54:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea10
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 55:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 55:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 55:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 55:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 55:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 55:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 55:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 55:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 55:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 55:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 55:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 55:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 55:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 55:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 55:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 55:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 55:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 55:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceedc0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134d37310
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 55:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 56:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 56:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 56:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 56:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 56:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 56:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 56:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 56:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 56:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 56:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 56:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 56:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 56:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 56:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 56:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 56:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 56:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 56:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceedc0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 56:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d35960
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceedc0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 57:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 57:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 57:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 57:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 57:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 57:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 57:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 57:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 57:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 57:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 57:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 57:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 57:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 57:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 57:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 57:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 57:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 57:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceea70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 57:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 58:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 58:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 58:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 58:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 58:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 58:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 58:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 58:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 58:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 58:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 58:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 58:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 58:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 58:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 58:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 58:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 58:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 58:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceea70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c752b0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 58:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 59:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 59:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 59:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 59:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 59:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 59:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 59:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea70
            pClearValues[0]:                const VkClearValue = 0x59d134ceea70 (Union):
                color:                          VkClearColorValue = 0x59d134ceea70 (Union):
                    float32:                        float[4] = 0x59d134ceea70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 59:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 59:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 59:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 59:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 59:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 59:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 59:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 59:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 59:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 59:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 59:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceea10
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 59:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea10
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceea70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 60:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 60:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 60:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 60:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 60:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 60:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 60:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 60:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 60:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 60:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 60:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 60:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 60:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 60:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 60:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 60:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 60:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 60:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c752b0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 60:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 61:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 61:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 61:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 61:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 61:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 61:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 61:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea70
            pClearValues[0]:                const VkClearValue = 0x59d134ceea70 (Union):
                color:                          VkClearColorValue = 0x59d134ceea70 (Union):
                    float32:                        float[4] = 0x59d134ceea70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 61:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 61:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 61:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 61:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 61:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 61:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 61:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 61:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 61:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 61:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 61:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 61:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 62:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 62:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 62:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 62:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 62:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 62:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 62:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea10
            pClearValues[0]:                const VkClearValue = 0x59d134ceea10 (Union):
                color:                          VkClearColorValue = 0x59d134ceea10 (Union):
                    float32:                        float[4] = 0x59d134ceea10
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea10
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea10
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea10:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 62:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 62:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 62:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 62:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 62:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 62:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 62:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 62:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 62:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 62:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 62:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000c48
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000c48:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea10
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c38bb0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d37310
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ce4f70
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 62:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37310
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c38bb0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 63:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 63:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 63:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 63:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 63:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 63:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 63:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 63:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 63:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 63:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 63:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 63:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 63:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 63:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 63:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 63:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 63:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 63:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d35960
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c38bb0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 63:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c38bb0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 64:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 64:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 64:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 64:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 64:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 64:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 64:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x753c14000ce0
            pClearValues[0]:                const VkClearValue = 0x753c14000ce0 (Union):
                color:                          VkClearColorValue = 0x753c14000ce0 (Union):
                    float32:                        float[4] = 0x753c14000ce0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x753c14000ce0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x753c14000ce0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x753c14000ce0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 64:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 64:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 64:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 64:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 64:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 64:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 64:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 64:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 64:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 64:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 64:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x753c14000ce0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d37310
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceea70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceea10
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 64:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37310
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x753c14000ce0
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 65:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 65:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 65:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 65:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 65:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 65:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 65:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c38bb0
            pClearValues[0]:                const VkClearValue = 0x59d134c38bb0 (Union):
                color:                          VkClearColorValue = 0x59d134c38bb0 (Union):
                    float32:                        float[4] = 0x59d134c38bb0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c38bb0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c38bb0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c38bb0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 65:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 65:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 65:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 65:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 65:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 65:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 65:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 65:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 65:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 65:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 65:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c38bb0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d35960
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceea10
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134c90a50
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 65:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea10
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 66:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 66:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 66:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 66:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 66:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 66:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 66:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceedc0
            pClearValues[0]:                const VkClearValue = 0x59d134ceedc0 (Union):
                color:                          VkClearColorValue = 0x59d134ceedc0 (Union):
                    float32:                        float[4] = 0x59d134ceedc0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceedc0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceedc0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceedc0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 66:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 66:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 66:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 66:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 66:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 66:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 66:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 66:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 66:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 66:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 66:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d37310
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134d35960
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ce4f70
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 66:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d35960
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d37310
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 67:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 67:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 67:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 67:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 67:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 67:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 67:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d37310
            pClearValues[0]:                const VkClearValue = 0x59d134d37310 (Union):
                color:                          VkClearColorValue = 0x59d134d37310 (Union):
                    float32:                        float[4] = 0x59d134d37310
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d37310
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d37310
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d37310:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 67:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 67:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 67:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 67:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 67:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 67:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 67:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 67:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 67:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 67:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 67:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c38bb0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134d35960
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ceea50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 67:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ceea50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134d35960
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 68:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 68:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 68:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 68:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 68:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 68:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 68:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134d35960
            pClearValues[0]:                const VkClearValue = 0x59d134d35960 (Union):
                color:                          VkClearColorValue = 0x59d134d35960 (Union):
                    float32:                        float[4] = 0x59d134d35960
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134d35960
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134d35960
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134d35960:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 68:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 68:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 68:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 68:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 68:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 68:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 68:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 68:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 68:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 68:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 68:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceea70
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ceea50
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134c90a50
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb300
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 68:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb300
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134c90a50
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ceea50
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 69:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 69:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 69:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 69:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 69:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 69:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 69:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ceea50
            pClearValues[0]:                const VkClearValue = 0x59d134ceea50 (Union):
                color:                          VkClearColorValue = 0x59d134ceea50 (Union):
                    float32:                        float[4] = 0x59d134ceea50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ceea50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ceea50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ceea50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 69:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 69:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 69:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 69:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 69:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 69:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 69:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 69:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 69:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 69:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 69:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134c90a50
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb3a0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 69:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134c90a50
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 70:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 70:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 70:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 70:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 70:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 70:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 70:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134c90a50
            pClearValues[0]:                const VkClearValue = 0x59d134c90a50 (Union):
                color:                          VkClearColorValue = 0x59d134c90a50 (Union):
                    float32:                        float[4] = 0x59d134c90a50
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134c90a50
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134c90a50
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134c90a50:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 70:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 70:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 70:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 70:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 70:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 70:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 70:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 70:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 70:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 70:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 70:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb3c0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb3e0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 70:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3e0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb3c0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 71:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 71:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 71:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 71:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 71:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 71:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 71:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 71:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 71:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 71:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 71:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 71:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 71:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 71:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 71:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 71:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 71:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 71:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb3c0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb480
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 71:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb480
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb3c0
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 72:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 72:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 72:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 72:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 72:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 72:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 72:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb3c0
            pClearValues[0]:                const VkClearValue = 0x59d134afb3c0 (Union):
                color:                          VkClearColorValue = 0x59d134afb3c0 (Union):
                    float32:                        float[4] = 0x59d134afb3c0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb3c0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb3c0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb3c0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 72:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 72:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 72:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 72:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 72:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 72:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 72:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 72:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 72:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 72:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 72:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef510
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef530
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 72:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef530
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 73:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 73:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 73:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 73:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 73:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 73:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 73:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 73:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 73:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 73:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 73:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 73:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 73:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 73:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 73:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 73:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 73:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 73:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb280
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 73:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb280
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef510
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 74:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 74:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 74:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 74:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 74:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 74:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 74:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef510
            pClearValues[0]:                const VkClearValue = 0x59d134cef510 (Union):
                color:                          VkClearColorValue = 0x59d134cef510 (Union):
                    float32:                        float[4] = 0x59d134cef510
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef510
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef510
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef510:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 74:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 74:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 74:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 74:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 74:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 74:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 74:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 74:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 74:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 74:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 74:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef510
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb2a0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 74:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb2a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef510
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 75:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 75:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 75:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 75:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 75:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 75:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 75:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 75:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 75:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 75:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 75:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 75:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 75:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 75:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 75:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 75:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 75:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 75:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef510
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef530
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ce4f70
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 75:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134ce4f70
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef530
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef510
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 76:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 76:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 76:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 76:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 76:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 76:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 76:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef510
            pClearValues[0]:                const VkClearValue = 0x59d134cef510 (Union):
                color:                          VkClearColorValue = 0x59d134cef510 (Union):
                    float32:                        float[4] = 0x59d134cef510
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef510
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef510
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef510:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 76:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 76:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 76:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 76:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 76:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 76:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 76:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 76:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 76:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 76:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 76:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef530
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb280
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 76:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb280
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef530
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 77:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 77:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 77:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 77:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 77:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 77:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 77:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef530
            pClearValues[0]:                const VkClearValue = 0x59d134cef530 (Union):
                color:                          VkClearColorValue = 0x59d134cef530 (Union):
                    float32:                        float[4] = 0x59d134cef530
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef530
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef530
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef530:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 77:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 77:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 77:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 77:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 77:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 77:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 77:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 77:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 77:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 77:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 77:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb280
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb2a0
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb380
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 77:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb380
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb2a0
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb280
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 78:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 78:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 78:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 78:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 78:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 78:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 78:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb280
            pClearValues[0]:                const VkClearValue = 0x59d134afb280 (Union):
                color:                          VkClearColorValue = 0x59d134afb280 (Union):
                    float32:                        float[4] = 0x59d134afb280
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb280
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb280
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb280:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 78:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 78:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 78:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 78:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 78:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 78:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 78:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 78:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 78:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 78:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 78:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb2a0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb280
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 78:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb280
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb2a0
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 79:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 79:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 79:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 79:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 79:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 79:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 79:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb2a0
            pClearValues[0]:                const VkClearValue = 0x59d134afb2a0 (Union):
                color:                          VkClearColorValue = 0x59d134afb2a0 (Union):
                    float32:                        float[4] = 0x59d134afb2a0
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb2a0
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb2a0
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb2a0:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 79:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 79:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 79:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 79:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 79:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 79:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 79:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 79:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 79:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 79:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 79:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb460
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb480
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 79:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb480
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb460
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 80:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 80:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 80:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 80:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 80:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 80:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 80:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 80:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 80:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 80:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 80:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 80:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 80:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 80:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 80:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 80:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 80:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 80:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb460
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 80:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb460
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 81:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 81:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 81:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 81:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 81:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 81:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 81:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb460
            pClearValues[0]:                const VkClearValue = 0x59d134afb460 (Union):
                color:                          VkClearColorValue = 0x59d134afb460 (Union):
                    float32:                        float[4] = 0x59d134afb460
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb460
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb460
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb460:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 81:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 81:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 81:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 81:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 81:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 81:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 81:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 81:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 81:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 81:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 81:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef570
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb280
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 81:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb280
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef570
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 82:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 82:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 82:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 82:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 82:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 82:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 82:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 82:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 82:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 82:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 82:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 82:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 82:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 82:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 82:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 82:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 82:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 82:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef570
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb2e0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 82:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb2e0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef570
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 83:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 83:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 83:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 83:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 83:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 83:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 83:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef570
            pClearValues[0]:                const VkClearValue = 0x59d134cef570 (Union):
                color:                          VkClearColorValue = 0x59d134cef570 (Union):
                    float32:                        float[4] = 0x59d134cef570
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef570
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef570
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef570:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 83:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 83:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 83:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 83:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 83:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 83:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 83:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 83:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 83:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 83:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 83:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb380
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb3a0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 83:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb380
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 84:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 84:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 84:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 84:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 84:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 84:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 84:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 84:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 84:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 84:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 84:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 84:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 84:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 84:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 84:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 84:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 84:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 84:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb380
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb400
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 84:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb400
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb380
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 85:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 85:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 85:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 85:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 85:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 85:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 85:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb380
            pClearValues[0]:                const VkClearValue = 0x59d134afb380 (Union):
                color:                          VkClearColorValue = 0x59d134afb380 (Union):
                    float32:                        float[4] = 0x59d134afb380
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb380
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb380
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb380:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 85:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 85:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 85:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 85:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 85:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 85:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 85:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 85:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 85:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 85:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 85:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb460
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb480
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 85:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb480
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb460
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 86:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 86:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 86:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 86:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 86:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 86:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 86:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 86:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 86:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 86:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 86:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 86:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 86:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 86:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 86:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 86:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 86:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 86:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb460
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 86:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb460
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 87:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 87:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 87:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 87:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 87:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 87:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 87:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb460
            pClearValues[0]:                const VkClearValue = 0x59d134afb460 (Union):
                color:                          VkClearColorValue = 0x59d134afb460 (Union):
                    float32:                        float[4] = 0x59d134afb460
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb460
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb460
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb460:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 87:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 87:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 87:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 87:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 87:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 87:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 87:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 87:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 87:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 87:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 87:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef570
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb280
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 87:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb280
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef570
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 88:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 88:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 88:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 88:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 88:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 88:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 88:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 88:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 88:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 88:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 88:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 88:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 88:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 88:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 88:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 88:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 88:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 88:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef570
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb2e0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 88:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb2e0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef570
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 89:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 89:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 89:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 89:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 89:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 89:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 89:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef570
            pClearValues[0]:                const VkClearValue = 0x59d134cef570 (Union):
                color:                          VkClearColorValue = 0x59d134cef570 (Union):
                    float32:                        float[4] = 0x59d134cef570
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef570
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef570
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef570:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 89:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 89:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 89:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 89:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 89:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 89:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 89:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 89:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 89:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 89:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 89:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb380
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb3a0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 89:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb380
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 90:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 90:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 90:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 90:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 90:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 90:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 90:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 90:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 90:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 90:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 90:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 90:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 90:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 90:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 90:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 90:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 90:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 90:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb380
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb400
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 90:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb400
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb380
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 91:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 91:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 91:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 91:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 91:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 91:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 91:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb380
            pClearValues[0]:                const VkClearValue = 0x59d134afb380 (Union):
                color:                          VkClearColorValue = 0x59d134afb380 (Union):
                    float32:                        float[4] = 0x59d134afb380
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb380
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb380
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb380:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 91:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 91:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 91:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 91:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 91:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 91:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 91:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 91:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 91:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 91:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 91:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb460
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb480
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 91:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb480
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb460
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 92:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 92:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 92:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 92:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 92:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 92:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 92:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 92:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 92:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 92:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 92:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 92:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 92:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 92:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 92:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 92:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 92:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 92:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb460
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134cef510
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 92:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134cef510
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb460
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 93:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 93:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 93:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 93:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 93:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 93:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 93:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb460
            pClearValues[0]:                const VkClearValue = 0x59d134afb460 (Union):
                color:                          VkClearColorValue = 0x59d134afb460 (Union):
                    float32:                        float[4] = 0x59d134afb460
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb460
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb460
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb460:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 93:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 93:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 93:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 93:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 93:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 93:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 93:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 93:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 93:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 93:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 93:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134cef570
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb280
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 93:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb280
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134cef570
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 94:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 94:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 94:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 94:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 94:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 94:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 94:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 94:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 94:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 94:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 94:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 94:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 94:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 94:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 94:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 94:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 94:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 94:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134cef570
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb2e0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 94:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb2e0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134cef570
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 95:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 95:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 95:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 95:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 95:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 95:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 95:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134cef570
            pClearValues[0]:                const VkClearValue = 0x59d134cef570 (Union):
                color:                          VkClearColorValue = 0x59d134cef570 (Union):
                    float32:                        float[4] = 0x59d134cef570
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134cef570
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134cef570
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134cef570:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 95:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 95:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 95:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 95:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 95:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 95:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 95:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 95:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 95:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 95:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 95:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134c90a50
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb380
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb3a0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 95:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb380
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 96:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 96:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 96:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 0

Thread 0, Frame 96:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 96:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 96:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 96:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c984f0
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134ce4f70
            pClearValues[0]:                const VkClearValue = 0x59d134ce4f70 (Union):
                color:                          VkClearColorValue = 0x59d134ce4f70 (Union):
                    float32:                        float[4] = 0x59d134ce4f70
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134ce4f70
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134ce4f70
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134ce4f70:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 96:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 96:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 96:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 96:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 96:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 96:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 96:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 96:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 96:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 96:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 96:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134ceedc0
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb380
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb400
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 96:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb400
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134ce4f70
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb380
            pImageIndices[0]:               const uint32_t = 0
        pResults:                       VkResult* = NULL

Thread 0, Frame 97:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 97:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 97:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 1

Thread 0, Frame 97:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 97:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 97:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 97:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c92510
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb380
            pClearValues[0]:                const VkClearValue = 0x59d134afb380 (Union):
                color:                          VkClearColorValue = 0x59d134afb380 (Union):
                    float32:                        float[4] = 0x59d134afb380
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb380
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb380
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb380:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 97:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 97:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 97:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 97:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 97:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 97:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 97:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 97:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 97:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 97:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 97:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134ce4f70
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134afb460
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134afb480
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 97:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb480
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134afb460
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134ce4f70
            pImageIndices[0]:               const uint32_t = 1
        pResults:                       VkResult* = NULL

Thread 0, Frame 98:
vkWaitForFences(device, fenceCount, pFences, waitAll, timeout) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868e0
        pFences[0]:                     const VkFence = 0x59d134c919e0
    waitAll:                        VkBool32 = 1
    timeout:                        uint64_t = 18446744073709551615

Thread 0, Frame 98:
vkResetFences(device, fenceCount, pFences) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    fenceCount:                     uint32_t = 1
    pFences:                        const VkFence* = 0x7fff3fe868f0
        pFences[0]:                     const VkFence = 0x59d134c919e0

Thread 0, Frame 98:
vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    timeout:                        uint64_t = 18446744073709551615
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    fence:                          VkFence = 0
    pImageIndex:                    uint32_t* = 2

Thread 0, Frame 98:
vkResetCommandBuffer(commandBuffer, flags) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    flags:                          VkCommandBufferResetFlags = 0

Thread 0, Frame 98:
vkBeginCommandBuffer(commandBuffer, pBeginInfo) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pBeginInfo:                     const VkCommandBufferBeginInfo* = 0x7fff3fe86b20:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (42)
        pNext:                          const void* = NULL
        flags:                          VkCommandBufferUsageFlags = 0
        pInheritanceInfo:               const VkCommandBufferInheritanceInfo* = UNUSED

Thread 0, Frame 98:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 98:
vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pRenderPassBegin:               const VkRenderPassBeginInfo* = 0x7fff3fe86890:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (43)
        pNext:                          const void* = NULL
        renderPass:                     VkRenderPass = 0x59d134b51170
        framebuffer:                    VkFramebuffer = 0x59d134c9b910
        renderArea:                     VkRect2D = 0x7fff3fe868b0:
            offset:                         VkOffset2D = 0x7fff3fe868b0:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe868b8:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080
        clearValueCount:                uint32_t = 1
        pClearValues:                   const VkClearValue* = 0x59d134afb480
            pClearValues[0]:                const VkClearValue = 0x59d134afb480 (Union):
                color:                          VkClearColorValue = 0x59d134afb480 (Union):
                    float32:                        float[4] = 0x59d134afb480
                        float32[0]:                     float = 0
                        float32[1]:                     float = 0
                        float32[2]:                     float = 0
                        float32[3]:                     float = 1
                    int32:                          int32_t[4] = 0x59d134afb480
                        int32[0]:                       int32_t = 0
                        int32[1]:                       int32_t = 0
                        int32[2]:                       int32_t = 0
                        int32[3]:                       int32_t = 1065353216
                    uint32:                         uint32_t[4] = 0x59d134afb480
                        uint32[0]:                      uint32_t = 0
                        uint32[1]:                      uint32_t = 0
                        uint32[2]:                      uint32_t = 0
                        uint32[3]:                      uint32_t = 1065353216
                depthStencil:                   VkClearDepthStencilValue = 0x59d134afb480:
                    depth:                          float = 0
                    stencil:                        uint32_t = 0
    contents:                       VkSubpassContents = VK_SUBPASS_CONTENTS_INLINE (0)

Thread 0, Frame 98:
vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    pipelineBindPoint:              VkPipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS (0)
    pipeline:                       VkPipeline = 0x59d134d23330

Thread 0, Frame 98:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 98:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 98:
vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstViewport:                  uint32_t = 0
    viewportCount:                  uint32_t = 1
    pViewports:                     const VkViewport* = 0x7fff3fe86a70
        pViewports[0]:                  const VkViewport = 0x7fff3fe86a70:
            x:                              float = 0
            y:                              float = 0
            width:                          float = 1920
            height:                         float = 1080
            minDepth:                       float = 0
            maxDepth:                       float = 1

Thread 0, Frame 98:
vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities) returns VkResult VK_SUCCESS (0):
    physicalDevice:                 VkPhysicalDevice = 0x59d134c70e80
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pSurfaceCapabilities:           VkSurfaceCapabilitiesKHR* = 0x7fff3fe869e0:
        minImageCount:                  uint32_t = 3
        maxImageCount:                  uint32_t = 0
        currentExtent:                  VkExtent2D = 0x7fff3fe869e8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        minImageExtent:                 VkExtent2D = 0x7fff3fe869f0:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageExtent:                 VkExtent2D = 0x7fff3fe869f8:
            width:                          uint32_t = 1920
            height:                         uint32_t = 1080
        maxImageArrayLayers:            uint32_t = 1
        supportedTransforms:            VkSurfaceTransformFlagsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        currentTransform:               VkSurfaceTransformFlagBitsKHR = 1 (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR)
        supportedCompositeAlpha:        VkCompositeAlphaFlagsKHR = 9 (VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR | VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR)
        supportedUsageFlags:            VkImageUsageFlags = 159 (VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)

Thread 0, Frame 98:
vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstScissor:                   uint32_t = 0
    scissorCount:                   uint32_t = 1
    pScissors:                      const VkRect2D* = 0x7fff3fe86a60
        pScissors[0]:                   const VkRect2D = 0x7fff3fe86a60:
            offset:                         VkOffset2D = 0x7fff3fe86a60:
                x:                              int32_t = 0
                y:                              int32_t = 0
            extent:                         VkExtent2D = 0x7fff3fe86a68:
                width:                          uint32_t = 1920
                height:                         uint32_t = 1080

Thread 0, Frame 98:
vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    firstBinding:                   uint32_t = 0
    bindingCount:                   uint32_t = 1
    pBuffers:                       const VkBuffer* = 0x7fff3fe868e0
        pBuffers[0]:                    const VkBuffer = 0x59d134b2dbb0
    pOffsets:                       const VkDeviceSize* = 0x7fff3fe86f98
        pOffsets[0]:                    const VkDeviceSize = 0

Thread 0, Frame 98:
vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700
    vertexCount:                    uint32_t = 3
    instanceCount:                  uint32_t = 1
    firstVertex:                    uint32_t = 0
    firstInstance:                  uint32_t = 0

Thread 0, Frame 98:
vkCmdEndRenderPass(commandBuffer) returns void:
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 98:
vkEndCommandBuffer(commandBuffer) returns VkResult VK_SUCCESS (0):
    commandBuffer:                  VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 98:
vkQueueSubmit(queue, submitCount, pSubmits, fence) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    submitCount:                    uint32_t = 1
    pSubmits:                       const VkSubmitInfo* = 0x753c14000d58
        pSubmits[0]:                    const VkSubmitInfo = 0x753c14000d58:
            sType:                          VkStructureType = VK_STRUCTURE_TYPE_SUBMIT_INFO (4)
            pNext:                          const void* = NULL
            waitSemaphoreCount:             uint32_t = 1
            pWaitSemaphores:                const VkSemaphore* = 0x59d134d37310
                pWaitSemaphores[0]:             const VkSemaphore = 0x59d134bdaaa0
            pWaitDstStageMask:              const VkPipelineStageFlags* = 0x59d134afb3a0
                pWaitDstStageMask[0]:           const VkPipelineStageFlags = 1024 (VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT)
            commandBufferCount:             uint32_t = 1
            pCommandBuffers:                const VkCommandBuffer* = 0x59d134ce4f70
                pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700
            signalSemaphoreCount:           uint32_t = 1
            pSignalSemaphores:              const VkSemaphore* = 0x59d134ceedc0
                pSignalSemaphores[0]:           const VkSemaphore = 0x59d134ba91e0
    fence:                          VkFence = 0x59d134c919e0

Thread 0, Frame 98:
vkQueuePresentKHR(queue, pPresentInfo) returns VkResult VK_SUCCESS (0):
    queue:                          VkQueue = 0x59d134c8e810
    pPresentInfo:                   const VkPresentInfoKHR* = 0x59d134d379a0:
        sType:                          VkStructureType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (1000001001)
        pNext:                          const void* = NULL
        waitSemaphoreCount:             uint32_t = 1
        pWaitSemaphores:                const VkSemaphore* = 0x59d134afb3a0
            pWaitSemaphores[0]:             const VkSemaphore = 0x59d134ba91e0
        swapchainCount:                 uint32_t = 1
        pSwapchains:                    const VkSwapchainKHR* = 0x59d134d37310
            pSwapchains[0]:                 const VkSwapchainKHR = 0x59d134c91a50
        pImageIndices:                  const uint32_t* = 0x59d134afb400
            pImageIndices[0]:               const uint32_t = 2
        pResults:                       VkResult* = NULL

Thread 0, Frame 99:
vkDeviceWaitIdle(device) returns VkResult VK_SUCCESS (0):
    device:                         VkDevice = 0x59d134c89710

Thread 0, Frame 99:
vkDestroySemaphore(device, semaphore, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    semaphore:                      VkSemaphore = 0x59d134ba91e0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroySemaphore(device, semaphore, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    semaphore:                      VkSemaphore = 0x59d134bdaaa0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyFence(device, fence, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    fence:                          VkFence = 0x59d134c919e0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers) returns void:
    device:                         VkDevice = 0x59d134c89710
    commandPool:                    VkCommandPool = 0x59d134ca02b0
    commandBufferCount:             uint32_t = 1
    pCommandBuffers:                const VkCommandBuffer* = 0x7fff3fe86ca8
        pCommandBuffers[0]:             const VkCommandBuffer = 0x59d134d26700

Thread 0, Frame 99:
vkDestroyFramebuffer(device, framebuffer, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    framebuffer:                    VkFramebuffer = 0x59d134c984f0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyFramebuffer(device, framebuffer, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    framebuffer:                    VkFramebuffer = 0x59d134c92510
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyFramebuffer(device, framebuffer, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    framebuffer:                    VkFramebuffer = 0x59d134c9b910
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyPipeline(device, pipeline, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    pipeline:                       VkPipeline = 0x59d134d23330
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyPipelineLayout(device, pipelineLayout, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    pipelineLayout:                 VkPipelineLayout = 0x59d134ce99b0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyRenderPass(device, renderPass, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    renderPass:                     VkRenderPass = 0x59d134b51170
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyBuffer(device, buffer, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    buffer:                         VkBuffer = 0x59d134b2dbb0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkFreeMemory(device, memory, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    memory:                         VkDeviceMemory = 0x59d134cef590
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyShaderModule(device, shaderModule, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    shaderModule:                   VkShaderModule = 0x59d134c93240
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyShaderModule(device, shaderModule, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    shaderModule:                   VkShaderModule = 0x59d134c943a0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyCommandPool(device, commandPool, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    commandPool:                    VkCommandPool = 0x59d134ca02b0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyCommandPool(device, commandPool, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    commandPool:                    VkCommandPool = 0x59d134c923c0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyImageView(device, imageView, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    imageView:                      VkImageView = 0x59d134c9dc30
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyImageView(device, imageView, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    imageView:                      VkImageView = 0x59d134c9e840
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyImageView(device, imageView, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    imageView:                      VkImageView = 0x59d134c9f4c0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroySwapchainKHR(device, swapchain, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    swapchain:                      VkSwapchainKHR = 0x59d134c91a50
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroySurfaceKHR(instance, surface, pAllocator) returns void:
    instance:                       VkInstance = 0x59d134ba5770
    surface:                        VkSurfaceKHR = 0x59d134c1d0d0
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyDevice(device, pAllocator) returns void:
    device:                         VkDevice = 0x59d134c89710
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator) returns void:
    instance:                       VkInstance = 0x59d134ba5770
    messenger:                      VkDebugUtilsMessengerEXT = 0x59d134c68b10
    pAllocator:                     const VkAllocationCallbacks* = NULL

Thread 0, Frame 99:
vkDestroyInstance(instance, pAllocator) returns void:
    instance:                       VkInstance = 0x59d134ba5770
    pAllocator:                     const VkAllocationCallbacks* = NULL

